/home/nsm/code/deepbrain/superconfig/crates/superconfig/src/config_flags.rs:
    1|       |//! Configuration flags for controlling `SuperConfig` V2 behavior
    2|       |//!
    3|       |//! This module provides two separate flag systems for different aspects of registry configuration:
    4|       |//!
    5|       |//! - **startup**: Flags that affect internal structures and must be set at registry creation
    6|       |//! - **runtime**: Flags that can be toggled during registry operation
    7|       |
    8|       |use thiserror::Error;
    9|       |
   10|       |/// Startup flags - affect internal structures and cannot be changed after registry creation
   11|       |pub mod startup {
   12|       |    /// No startup flags enabled - minimal configuration
   13|       |    pub const NO_FLAGS: u32 = 0;
   14|       |
   15|       |    /// Enable SIMD acceleration for parsing operations
   16|       |    /// Affects parser pipeline initialization
   17|       |    pub const SIMD: u32 = 1 << 0;
   18|       |
   19|       |    /// Pre-allocate thread pool for parallel operations
   20|       |    /// Thread pool cannot be created/destroyed at runtime
   21|       |    pub const THREAD_POOL: u32 = 1 << 1;
   22|       |
   23|       |    /// Enable detailed statistics collection with comprehensive metrics
   24|       |    /// Statistics structure affects memory layout
   25|       |    pub const DETAILED_STATS: u32 = 1 << 2;
   26|       |}
   27|       |
   28|       |/// Runtime flags - can be enabled/disabled freely without affecting core structures
   29|       |pub mod runtime {
   30|       |    /// Enable array merge operations with _ADD/_REMOVE suffixes
   31|       |    /// Can be disabled for security in production environments
   32|       |    pub const ARRAY_MERGE: u64 = 1 << 0;
   33|       |
   34|       |    /// Enable parallel loading for multiple configuration files
   35|       |    /// Can be disabled to reduce resource usage
   36|       |    pub const PARALLEL: u64 = 1 << 1;
   37|       |
   38|       |    /// Enable strict validation mode with comprehensive error checking
   39|       |    /// Can be toggled based on environment (development vs production)
   40|       |    pub const STRICT_MODE: u64 = 1 << 2;
   41|       |
   42|       |    /// Enable environment variable expansion (${VAR} syntax)
   43|       |    /// Can be disabled for security in production environments
   44|       |    pub const ENV_EXPANSION: u64 = 1 << 3;
   45|       |
   46|       |    /// Enable format auto-detection fallbacks when explicit format fails
   47|       |    /// Can be disabled for strict format requirements
   48|       |    pub const FORMAT_FALLBACK: u64 = 1 << 4;
   49|       |}
   50|       |
   51|       |/// Errors that can occur during flag operations
   52|       |#[derive(Error, Debug, Clone)]
   53|       |pub enum FlagError {
   54|       |    /// Attempted to modify startup flags at runtime
   55|       |    #[error("Cannot modify startup flags at runtime - they are immutable after registry creation")]
   56|       |    ImmutableStartupFlag,
   57|       |
   58|       |    /// Invalid runtime flag value
   59|       |    #[error("Invalid runtime flag value: 0x{flags:X}")]
   60|       |    InvalidFlag {
   61|       |        /// The invalid flag value
   62|       |        flags: u64,
   63|       |    },
   64|       |
   65|       |    /// Invalid runtime flag value (legacy)
   66|       |    #[error("Invalid runtime flag value: 0x{flag:X}")]
   67|       |    InvalidRuntimeFlag {
   68|       |        /// The invalid flag value
   69|       |        flag: u64,
   70|       |    },
   71|       |
   72|       |    /// Invalid startup flag value  
   73|       |    #[error("Invalid startup flag value: 0x{flag:X}")]
   74|       |    InvalidStartupFlag {
   75|       |        /// The invalid flag value
   76|       |        flag: u32,
   77|       |    },
   78|       |}
   79|       |
   80|       |/// All valid runtime flags combined
   81|       |const ALL_RUNTIME_FLAGS: u64 = runtime::ARRAY_MERGE
   82|       |    | runtime::PARALLEL
   83|       |    | runtime::STRICT_MODE
   84|       |    | runtime::ENV_EXPANSION
   85|       |    | runtime::FORMAT_FALLBACK;
   86|       |
   87|       |/// All valid startup flags combined  
   88|       |const ALL_STARTUP_FLAGS: u32 = startup::SIMD | startup::THREAD_POOL | startup::DETAILED_STATS;
   89|       |
   90|       |/// Check if a runtime flag value contains only valid flags
   91|       |///
   92|       |/// # Examples
   93|       |/// ```
   94|       |/// use superconfig::config_flags::{self, runtime};
   95|       |///
   96|       |/// assert!(config_flags::is_valid_runtime_flag(runtime::STRICT_MODE));
   97|       |/// assert!(config_flags::is_valid_runtime_flag(runtime::PARALLEL | runtime::STRICT_MODE));
   98|       |/// assert!(!config_flags::is_valid_runtime_flag(0xFFFFFFFF)); // Invalid flag
   99|       |/// ```
  100|       |#[must_use]
  101|     43|pub const fn is_valid_runtime_flag(flags: u64) -> bool {
  102|       |    // Check if all bits in flags are covered by valid runtime flags
  103|     43|    (flags & !ALL_RUNTIME_FLAGS) == 0
  104|     43|}
  105|       |
  106|       |/// Check if a startup flag value contains only valid flags
  107|       |///
  108|       |/// # Examples  
  109|       |/// ```
  110|       |/// use superconfig::config_flags::{self, startup};
  111|       |///
  112|       |/// assert!(config_flags::is_valid_startup_flag(startup::SIMD));
  113|       |/// assert!(config_flags::is_valid_startup_flag(startup::SIMD | startup::THREAD_POOL));
  114|       |/// assert!(!config_flags::is_valid_startup_flag(0xFFFFFFFF)); // Invalid flag
  115|       |/// ```
  116|       |#[must_use]
  117|     10|pub const fn is_valid_startup_flag(flags: u32) -> bool {
  118|       |    // Check if all bits in flags are covered by valid startup flags
  119|     10|    (flags & !ALL_STARTUP_FLAGS) == 0
  120|     10|}
  121|       |
  122|       |#[cfg(test)]
  123|       |mod tests {
  124|       |    use super::*;
  125|       |
  126|       |    #[test]
  127|      1|    fn test_startup_flag_constants() {
  128|      1|        assert_eq!(startup::SIMD, 1);
  129|      1|        assert_eq!(startup::THREAD_POOL, 2);
  130|      1|        assert_eq!(startup::DETAILED_STATS, 4);
  131|       |
  132|       |        // Ensure flags are unique (can be combined with |)
  133|      1|        let combined = startup::SIMD | startup::THREAD_POOL;
  134|      1|        assert_eq!(combined, 3);
  135|      1|    }
  136|       |
  137|       |    #[test]
  138|      1|    fn test_runtime_flag_constants() {
  139|      1|        assert_eq!(runtime::ARRAY_MERGE, 1);
  140|      1|        assert_eq!(runtime::PARALLEL, 2);
  141|      1|        assert_eq!(runtime::STRICT_MODE, 4);
  142|      1|        assert_eq!(runtime::ENV_EXPANSION, 8);
  143|      1|        assert_eq!(runtime::FORMAT_FALLBACK, 16);
  144|       |
  145|       |        // Ensure flags are unique
  146|      1|        let combined = runtime::ARRAY_MERGE | runtime::STRICT_MODE;
  147|      1|        assert_eq!(combined, 5);
  148|      1|    }
  149|       |
  150|       |    #[test]
  151|      1|    fn test_flag_combinations() {
  152|       |        // Test that startup and runtime can use same bit positions without conflict
  153|      1|        assert_eq!(startup::SIMD, 1); // u32
  154|      1|        assert_eq!(runtime::ARRAY_MERGE, 1); // u64
  155|       |
  156|       |        // They're different types so no collision
  157|      1|        let startup_flags = startup::SIMD | startup::THREAD_POOL;
  158|      1|        let runtime_flags = runtime::ARRAY_MERGE | runtime::PARALLEL;
  159|       |
  160|      1|        assert_eq!(startup_flags, 3u32);
  161|      1|        assert_eq!(runtime_flags, 3u64);
  162|      1|    }
  163|       |
  164|       |    #[test]
  165|      1|    fn test_error_display() {
  166|      1|        let error = FlagError::ImmutableStartupFlag;
  167|      1|        assert!(format!("{error}").contains("immutable"));
  168|      1|    }
  169|       |
  170|       |    #[test]
  171|      1|    fn test_runtime_flag_validation() {
  172|       |        // Valid individual flags
  173|      1|        assert!(is_valid_runtime_flag(runtime::ARRAY_MERGE));
  174|      1|        assert!(is_valid_runtime_flag(runtime::PARALLEL));
  175|      1|        assert!(is_valid_runtime_flag(runtime::STRICT_MODE));
  176|      1|        assert!(is_valid_runtime_flag(runtime::ENV_EXPANSION));
  177|      1|        assert!(is_valid_runtime_flag(runtime::FORMAT_FALLBACK));
  178|       |
  179|       |        // Valid combinations
  180|      1|        assert!(is_valid_runtime_flag(
  181|      1|            runtime::STRICT_MODE | runtime::PARALLEL
  182|       |        ));
  183|      1|        assert!(is_valid_runtime_flag(
  184|      1|            runtime::ARRAY_MERGE | runtime::ENV_EXPANSION
  185|       |        ));
  186|       |
  187|       |        // All flags combined should be valid
  188|      1|        assert!(is_valid_runtime_flag(ALL_RUNTIME_FLAGS));
  189|       |
  190|       |        // Invalid flags
  191|      1|        assert!(!is_valid_runtime_flag(0xFFFFFFFF)); // Invalid flag
  192|      1|        assert!(!is_valid_runtime_flag(1 << 10)); // Unused bit
  193|      1|        assert!(!is_valid_runtime_flag(0xFF00)); // High bits
  194|       |
  195|       |        // Zero should be valid (no flags set)
  196|      1|        assert!(is_valid_runtime_flag(0));
  197|      1|    }
  198|       |
  199|       |    #[test]
  200|      1|    fn test_startup_flag_validation() {
  201|       |        // Valid individual flags
  202|      1|        assert!(is_valid_startup_flag(startup::SIMD));
  203|      1|        assert!(is_valid_startup_flag(startup::THREAD_POOL));
  204|      1|        assert!(is_valid_startup_flag(startup::DETAILED_STATS));
  205|       |
  206|       |        // Valid combinations
  207|      1|        assert!(is_valid_startup_flag(startup::SIMD | startup::THREAD_POOL));
  208|      1|        assert!(is_valid_startup_flag(
  209|      1|            startup::SIMD | startup::DETAILED_STATS
  210|       |        ));
  211|       |
  212|       |        // All flags combined should be valid
  213|      1|        assert!(is_valid_startup_flag(ALL_STARTUP_FLAGS));
  214|       |
  215|       |        // Invalid flags
  216|      1|        assert!(!is_valid_startup_flag(0xFFFFFFFF)); // Invalid flag
  217|      1|        assert!(!is_valid_startup_flag(1 << 10)); // Unused bit
  218|      1|        assert!(!is_valid_startup_flag(0xFF00)); // High bits
  219|       |
  220|       |        // Zero should be valid (no flags set)
  221|      1|        assert!(is_valid_startup_flag(0));
  222|      1|    }
  223|       |}

/home/nsm/code/deepbrain/superconfig/crates/superconfig/src/core/handle.rs:
    1|       |//! Type-safe handles for accessing configuration data
    2|       |
    3|       |use super::registry::HandleId;
    4|       |use serde::{Deserialize, Serialize};
    5|       |use std::marker::PhantomData;
    6|       |
    7|       |/// Type-safe handle for accessing configuration data
    8|       |///
    9|       |/// Handles provide zero-cost type safety for registry operations.
   10|       |/// They serialize as just the handle ID for efficient FFI usage.
   11|       |///
   12|       |/// # Examples
   13|       |///
   14|       |/// ```
   15|       |/// use superconfig::ConfigRegistry;
   16|       |///
   17|       |/// #[derive(Clone, PartialEq, Debug)]
   18|       |/// struct MyConfig {
   19|       |///     host: String,
   20|       |///     port: u16,
   21|       |/// }
   22|       |///
   23|       |/// let registry = ConfigRegistry::new();
   24|       |/// let config = MyConfig {
   25|       |///     host: "localhost".to_string(),
   26|       |///     port: 8080,
   27|       |/// };
   28|       |///
   29|       |/// let handle = registry.create(config.clone()).unwrap();
   30|       |/// let retrieved = registry.read(&handle).unwrap();
   31|       |/// assert_eq!(*retrieved, config);
   32|       |/// ```
   33|       |#[derive(Debug, Clone, Copy)]
   34|       |pub struct ConfigHandle<T> {
   35|       |    id: HandleId,
   36|       |    _phantom: PhantomData<T>,
   37|       |}
   38|       |
   39|       |impl<T> ConfigHandle<T> {
   40|       |    /// Create a new handle with the given ID
   41|       |    ///
   42|       |    /// This is primarily used internally by the registry
   43|  1.05k|    pub(crate) const fn new(id: HandleId) -> Self {
   44|  1.05k|        Self {
   45|  1.05k|            id,
   46|  1.05k|            _phantom: PhantomData,
   47|  1.05k|        }
   48|  1.05k|    }
   49|       |
   50|       |    /// Get the handle ID
   51|       |    ///
   52|       |    /// # Examples
   53|       |    ///
   54|       |    /// ```
   55|       |    /// use superconfig::ConfigRegistry;
   56|       |    ///
   57|       |    /// let registry = ConfigRegistry::new();
   58|       |    /// let handle = registry.create("test".to_string()).unwrap();
   59|       |    ///
   60|       |    /// let id = handle.id();
   61|       |    /// assert_eq!(id, 1); // First handle gets ID 1
   62|       |    /// ```
   63|       |    #[must_use]
   64|  2.42k|    pub const fn id(&self) -> HandleId {
   65|  2.42k|        self.id
   66|  2.42k|    }
   67|       |}
   68|       |
   69|       |/// Handles serialize as just their ID for efficient FFI usage
   70|       |impl<T> Serialize for ConfigHandle<T> {
   71|      2|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   72|      2|    where
   73|      2|        S: serde::Serializer,
   74|       |    {
   75|      2|        self.id.serialize(serializer)
   76|      2|    }
   77|       |}
   78|       |
   79|       |/// Handles deserialize from their ID
   80|       |impl<'de, T> Deserialize<'de> for ConfigHandle<T> {
   81|      2|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   82|      2|    where
   83|      2|        D: serde::Deserializer<'de>,
   84|       |    {
   85|      2|        let id = HandleId::deserialize(deserializer)?;
                                                                  ^0
   86|      2|        Ok(Self::new(id))
   87|      2|    }
   88|       |}
   89|       |
   90|       |// Implement common traits for ergonomic usage
   91|       |impl<T> PartialEq for ConfigHandle<T> {
   92|      4|    fn eq(&self, other: &Self) -> bool {
   93|      4|        self.id == other.id
   94|      4|    }
   95|       |}
   96|       |
   97|       |impl<T> Eq for ConfigHandle<T> {}
   98|       |
   99|       |impl<T> std::hash::Hash for ConfigHandle<T> {
  100|      3|    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
  101|      3|        self.id.hash(state);
  102|      3|    }
  103|       |}
  104|       |
  105|       |#[cfg(test)]
  106|       |mod tests {
  107|       |    use super::*;
  108|       |    use serde_json;
  109|       |
  110|       |    #[derive(Debug, Clone, Copy, PartialEq)]
  111|       |    struct TestConfig {
  112|       |        value: i32,
  113|       |    }
  114|       |
  115|       |    #[test]
  116|      1|    fn test_handle_creation() {
  117|      1|        let handle = ConfigHandle::<TestConfig>::new(42);
  118|      1|        assert_eq!(handle.id(), 42);
  119|      1|    }
  120|       |
  121|       |    #[test]
  122|      1|    fn test_handle_serialization() {
  123|      1|        let handle = ConfigHandle::<TestConfig>::new(123);
  124|       |
  125|      1|        let serialized = serde_json::to_string(&handle).unwrap();
  126|      1|        assert_eq!(serialized, "123");
  127|       |
  128|      1|        let deserialized: ConfigHandle<TestConfig> = serde_json::from_str(&serialized).unwrap();
  129|      1|        assert_eq!(handle.id(), deserialized.id());
  130|      1|    }
  131|       |
  132|       |    #[test]
  133|      1|    fn test_handle_equality() {
  134|      1|        let handle1 = ConfigHandle::<TestConfig>::new(1);
  135|      1|        let handle2 = ConfigHandle::<TestConfig>::new(1);
  136|      1|        let handle3 = ConfigHandle::<TestConfig>::new(2);
  137|       |
  138|      1|        assert_eq!(handle1, handle2);
  139|      1|        assert_ne!(handle1, handle3);
  140|      1|    }
  141|       |
  142|       |    #[test]
  143|      1|    fn test_handle_hash() {
  144|       |        use std::collections::HashSet;
  145|       |
  146|      1|        let handle1 = ConfigHandle::<TestConfig>::new(1);
  147|      1|        let handle2 = ConfigHandle::<TestConfig>::new(1);
  148|      1|        let handle3 = ConfigHandle::<TestConfig>::new(2);
  149|       |
  150|      1|        let mut set = HashSet::new();
  151|      1|        set.insert(handle1);
  152|      1|        set.insert(handle2); // Should not increase size (same ID)
  153|      1|        set.insert(handle3);
  154|       |
  155|      1|        assert_eq!(set.len(), 2);
  156|      1|    }
  157|       |
  158|       |    #[test]
  159|      1|    fn test_handle_copy() {
  160|      1|        let handle1 = ConfigHandle::<TestConfig>::new(42);
  161|      1|        let handle2 = handle1; // Should copy, not move
  162|       |
  163|      1|        assert_eq!(handle1.id(), 42);
  164|      1|        assert_eq!(handle2.id(), 42);
  165|      1|    }
  166|       |
  167|       |    #[test]
  168|      1|    fn test_handle_debug() {
  169|      1|        let handle = ConfigHandle::<TestConfig>::new(999);
  170|      1|        let debug_str = format!("{handle:?}");
  171|       |
  172|      1|        assert!(debug_str.contains("999"));
  173|      1|        assert!(debug_str.contains("ConfigHandle"));
  174|      1|    }
  175|       |
  176|       |    #[test]
  177|      1|    fn test_phantom_data_zero_cost() {
  178|       |        use std::mem;
  179|       |
  180|       |        // Handle should be same size as HandleId (u64)
  181|      1|        assert_eq!(
  182|       |            mem::size_of::<ConfigHandle<TestConfig>>(),
  183|       |            mem::size_of::<HandleId>()
  184|       |        );
  185|      1|        assert_eq!(
  186|       |            mem::size_of::<ConfigHandle<String>>(),
  187|       |            mem::size_of::<HandleId>()
  188|       |        );
  189|      1|    }
  190|       |
  191|       |    #[test]
  192|      1|    fn test_handle_json_roundtrip() {
  193|      1|        let original = ConfigHandle::<TestConfig>::new(12345);
  194|       |
  195|       |        // Serialize to JSON
  196|      1|        let json = serde_json::to_string(&original).unwrap();
  197|      1|        assert_eq!(json, "12345");
  198|       |
  199|       |        // Deserialize from JSON
  200|      1|        let restored: ConfigHandle<TestConfig> = serde_json::from_str(&json).unwrap();
  201|       |
  202|      1|        assert_eq!(original, restored);
  203|      1|        assert_eq!(original.id(), restored.id());
  204|      1|    }
  205|       |
  206|       |    #[test]
  207|      1|    fn test_different_types_different_handles() {
  208|       |        // Even with same ID, handles with different types are different types
  209|      1|        let handle_string = ConfigHandle::<String>::new(1);
  210|      1|        let handle_int = ConfigHandle::<i32>::new(1);
  211|       |
  212|       |        // These should be different types (won't compile if we try to compare them)
  213|      1|        assert_eq!(handle_string.id(), handle_int.id()); // IDs are same
  214|       |        // handle_string == handle_int; // This won't compile - good!
  215|      1|    }
  216|       |}

/home/nsm/code/deepbrain/superconfig/crates/superconfig/src/core/registry.rs:
    1|       |//! Main configuration registry implementation
    2|       |
    3|       |use dashmap::DashMap;
    4|       |use parking_lot::RwLock;
    5|       |use std::{
    6|       |    sync::{
    7|       |        Arc,
    8|       |        atomic::{AtomicU64, Ordering},
    9|       |    },
   10|       |    time::Instant,
   11|       |};
   12|       |use superconfig_macros::generate_json_helper;
   13|       |
   14|       |use super::{
   15|       |    handle::ConfigHandle,
   16|       |    stats::RegistryStats,
   17|       |};
   18|       |use logffi::error;
   19|       |
   20|       |/// Unique identifier for configuration handles
   21|       |pub type HandleId = u64;
   22|       |
   23|       |/// Internal entry stored in the registry
   24|       |#[derive(Debug)]
   25|       |struct ConfigEntry {
   26|       |    /// The actual configuration data
   27|       |    data: Box<dyn std::any::Any + Send + Sync>,
   28|       |    /// Type name for runtime type checking
   29|       |    type_name: &'static str,
   30|       |    /// When this entry was created (used for cache eviction in Phase 5)
   31|       |    #[allow(dead_code)]
   32|       |    created_at: Instant,
   33|       |    /// When this entry was last accessed (used for LRU eviction in Phase 5)
   34|       |    #[allow(dead_code)]
   35|       |    last_accessed: Instant,
   36|       |    /// Registry-level reference count (for statistics, separate from Arc's count)
   37|       |    #[allow(dead_code)]
   38|       |    ref_count: AtomicU64,
   39|       |    /// Size of the data in bytes (approximate)
   40|       |    data_size: usize,
   41|       |}
   42|       |
   43|       |impl ConfigEntry {
   44|  1.53k|    fn new<T: 'static + Send + Sync>(data: T) -> Self {
   45|  1.53k|        let data_size = std::mem::size_of::<T>();
   46|  1.53k|        Self {
   47|  1.53k|            data: Box::new(Arc::new(data)), // Always store as Arc<T>
   48|  1.53k|            type_name: std::any::type_name::<T>(),
   49|  1.53k|            created_at: Instant::now(),
   50|  1.53k|            last_accessed: Instant::now(),
   51|  1.53k|            ref_count: AtomicU64::new(1),
   52|  1.53k|            data_size,
   53|  1.53k|        }
   54|  1.53k|    }
   55|       |
   56|  1.02k|    fn get_arc_data<T: 'static>(&self) -> Result<Arc<T>, String> {
   57|  1.02k|        let expected_type = std::any::type_name::<T>();
   58|  1.02k|        if self.type_name != expected_type {
   59|      1|            let error_msg = format!("superconfig.registry: Wrong type, expected {}, found {}", expected_type, self.type_name);
   60|      1|            error!(target: "superconfig.registry", "Wrong type, expected {}, found {}", expected_type, self.type_name);
                                         ^0                      ^0
   61|      1|            return Err(error_msg);
   62|  1.02k|        }
   63|       |
   64|       |        // If we get here, downcast must succeed
   65|  1.02k|        Ok(self.data.downcast_ref::<Arc<T>>().unwrap().clone())
   66|  1.02k|    }
   67|       |}
   68|       |
   69|       |/// Main configuration registry using lock-free operations
   70|       |///
   71|       |/// The registry provides handle-based access to configuration data with sub-microsecond
   72|       |/// lookup times. It supports both startup flags (immutable after creation) and runtime
   73|       |/// flags (mutable during operation).
   74|       |///
   75|       |/// # Examples
   76|       |///
   77|       |/// ```
   78|       |/// use superconfig::{ConfigRegistry, config_flags::{startup, runtime}};
   79|       |///
   80|       |/// // Create registry with startup flags
   81|       |/// let registry = ConfigRegistry::custom(startup::SIMD | startup::THREAD_POOL)
   82|       |///     .enable(runtime::STRICT_MODE);
   83|       |///
   84|       |/// // Store configuration
   85|       |/// let handle = registry.create("localhost".to_string()).unwrap();
   86|       |/// let config = registry.read(&handle).unwrap();
   87|       |/// assert_eq!(*config, "localhost");
   88|       |/// ```
   89|       |pub struct ConfigRegistry {
   90|       |    /// Internal storage using `DashMap` for lock-free operations
   91|       |    entries: DashMap<HandleId, ConfigEntry>,
   92|       |    /// Atomic counter for generating unique handle IDs
   93|       |    next_id: AtomicU64,
   94|       |    /// Registry statistics protected by `RwLock`
   95|       |    stats: Arc<RwLock<RegistryStats>>,
   96|       |    /// Startup flags - immutable after registry creation
   97|       |    startup_flags: u32,
   98|       |    /// Runtime flags - mutable at runtime
   99|       |    runtime_flags: Arc<parking_lot::RwLock<u64>>,
  100|       |}
  101|       |
  102|       |impl ConfigRegistry {
  103|       |    /// Create a new configuration registry with default settings (no startup flags)
  104|       |    ///
  105|       |    /// Does not set any log level by default - respects existing logger configuration
  106|       |    /// (e.g., `RUST_LOG` environment variable) or your application's logging setup.
  107|       |    /// Use logffi directly to configure logging as needed.
  108|       |    ///
  109|       |    /// Returns Arc<ConfigRegistry> for consistent Arc-based chaining with all methods.
  110|       |    ///
  111|       |    /// # Examples
  112|       |    /// ```
  113|       |    /// use superconfig::ConfigRegistry;
  114|       |    /// use std::sync::Arc;
  115|       |    ///
  116|       |    /// // No automatic logging - respects your app's logger setup
  117|       |    /// let registry = ConfigRegistry::new();
  118|       |    ///
  119|       |    /// // Configure logging separately with logffi
  120|       |    /// logffi::set_max_level(logffi::LevelFilter::Warn);
  121|       |    /// ```
  122|       |    #[must_use]
  123|     43|    pub fn new() -> Arc<Self> {
  124|     43|        Self::custom(crate::config_flags::startup::NO_FLAGS)
  125|     43|    }
  126|       |
  127|       |    /// Create a new configuration registry with custom startup flags
  128|       |    ///
  129|       |    /// Startup flags affect internal structures and cannot be changed after creation.
  130|       |    /// Returns Arc<ConfigRegistry> for consistent Arc-based chaining with all methods.
  131|       |    ///
  132|       |    /// # Examples
  133|       |    /// ```
  134|       |    /// use superconfig::{ConfigRegistry, config_flags::startup};
  135|       |    /// use std::sync::Arc;
  136|       |    ///
  137|       |    /// let registry = ConfigRegistry::custom(startup::SIMD | startup::THREAD_POOL);
  138|       |    /// // registry is Arc<ConfigRegistry>, ready for Arc-based chaining
  139|       |    /// ```
  140|       |    #[must_use]
  141|     46|    pub fn custom(startup_flags: u32) -> Arc<Self> {
  142|     46|        Arc::new(Self {
  143|     46|            entries: DashMap::new(),
  144|     46|            next_id: AtomicU64::new(1),
  145|     46|            stats: Arc::new(RwLock::new(RegistryStats::default())),
  146|     46|            startup_flags,
  147|     46|            runtime_flags: Arc::new(parking_lot::RwLock::new(0)),
  148|     46|        })
  149|     46|    }
  150|       |
  151|       |    // Flag management methods
  152|       |
  153|       |    /// Enable runtime flags (startup flags cannot be modified after creation)
  154|       |    ///
  155|       |    /// This method works with Arc<ConfigRegistry> for consistent Arc-based chaining.
  156|       |    /// Always returns Arc<Self> to continue the chain, errors are collected internally.
  157|       |    ///
  158|       |    /// # Examples
  159|       |    /// ```
  160|       |    /// use superconfig::{ConfigRegistry, config_flags::runtime};
  161|       |    ///
  162|       |    /// let registry = ConfigRegistry::new()
  163|       |    ///     .enable(runtime::STRICT_MODE)    // Always continues chain
  164|       |    ///     .enable(runtime::PARALLEL);      // Always continues chain
  165|       |    /// ```
  166|       |    #[generate_json_helper(outgoing, handle_mode)]
  167|     24|    pub fn enable(self: Arc<Self>, flags: u64) -> Arc<Self> {
  168|       |        // Validate flags - check if it's a known runtime flag
  169|     24|        if !crate::config_flags::is_valid_runtime_flag(flags) {
  170|      2|            error!(target: "superconfig.flags", "Invalid runtime flag: 0x{:X}", flags);
                                         ^0                   ^0
  171|      2|            return self;
  172|     22|        }
  173|       |
  174|       |        // Directly modify the runtime flags through the Arc
  175|     22|        {
  176|     22|            let mut runtime_flags = self.runtime_flags.write();
  177|     22|            *runtime_flags |= flags;
  178|     22|        }
  179|     22|        self
  180|     24|    }
  181|       |
  182|       |    /// Disable runtime flags (startup flags cannot be modified after creation)
  183|       |    ///
  184|       |    /// This method works with Arc<ConfigRegistry> for consistent Arc-based chaining.
  185|       |    /// Always returns Arc<Self> to continue the chain, errors are collected internally.
  186|       |    ///
  187|       |    /// # Examples
  188|       |    /// ```
  189|       |    /// use superconfig::{ConfigRegistry, config_flags::runtime};
  190|       |    ///
  191|       |    /// let registry = ConfigRegistry::new()
  192|       |    ///     .enable(runtime::STRICT_MODE)    // Enable first
  193|       |    ///     .disable(runtime::STRICT_MODE);  // Then disable
  194|       |    /// ```
  195|       |    #[generate_json_helper(outgoing, handle_mode)]
  196|      7|    pub fn disable(self: Arc<Self>, flags: u64) -> Arc<Self> {
  197|       |        // Validate flags - check if it's a known runtime flag
  198|      7|        if !crate::config_flags::is_valid_runtime_flag(flags) {
  199|      2|            error!(target: "superconfig.flags", "Invalid runtime flag: 0x{:X}", flags);
                                         ^0                   ^0
  200|      2|            return self;
  201|      5|        }
  202|       |
  203|       |        // Directly modify the runtime flags through the Arc
  204|      5|        {
  205|      5|            let mut runtime_flags = self.runtime_flags.write();
  206|      5|            *runtime_flags &= !flags;
  207|      5|        }
  208|      5|        self
  209|      7|    }
  210|       |
  211|       |    /// Check if startup flags are enabled
  212|       |    #[must_use]
  213|      7|    pub const fn startup_enabled(&self, flags: u32) -> bool {
  214|      7|        (self.startup_flags & flags) != 0
  215|      7|    }
  216|       |
  217|       |    /// Check if startup flags are disabled
  218|       |    #[must_use]
  219|      1|    pub const fn startup_disabled(&self, flags: u32) -> bool {
  220|      1|        !self.startup_enabled(flags)
  221|      1|    }
  222|       |
  223|       |    /// Check if runtime flags are enabled
  224|       |    #[must_use]
  225|     24|    pub fn runtime_enabled(&self, flags: u64) -> bool {
  226|     24|        let runtime_flags = self.runtime_flags.read();
  227|     24|        (*runtime_flags & flags) != 0
  228|     24|    }
  229|       |
  230|       |    /// Check if runtime flags are disabled
  231|       |    #[must_use]
  232|      1|    pub fn runtime_disabled(&self, flags: u64) -> bool {
  233|      1|        !self.runtime_enabled(flags)
  234|      1|    }
  235|       |
  236|       |    /// Get current startup flags
  237|       |    #[must_use]
  238|      1|    pub const fn get_startup_flags(&self) -> u32 {
  239|      1|        self.startup_flags
  240|      1|    }
  241|       |
  242|       |    /// Get current runtime flags
  243|       |    #[must_use]
  244|      3|    pub fn get_runtime_flags(&self) -> u64 {
  245|      3|        *self.runtime_flags.read()
  246|      3|    }
  247|       |}
  248|       |
  249|       |// CRUD Operations
  250|       |
  251|       |impl ConfigRegistry {
  252|       |    /// Create a new configuration entry and return a handle to it
  253|       |    ///
  254|       |    /// Returns `Arc<T>` for efficient sharing. Use field access (`config.host`)
  255|       |    /// and method calls (`config.validate()`) directly - they're zero-cost due to auto-deref.
  256|       |    ///
  257|       |    /// # Errors
  258|       |    ///
  259|       |    /// Returns `RegistryError::RegistryFull` if the registry has reached maximum capacity.
  260|       |    ///
  261|       |    /// # Examples
  262|       |    ///
  263|       |    /// ```
  264|       |    /// use superconfig::ConfigRegistry;
  265|       |    ///
  266|       |    /// let registry = ConfigRegistry::new();
  267|       |    /// let handle = registry.create("my config".to_string()).unwrap();
  268|       |    /// assert_eq!(handle.id(), 1);
  269|       |    /// ```
  270|  1.03k|    pub fn create<T: 'static + Send + Sync>(
  271|  1.03k|        &self,
  272|  1.03k|        data: T,
  273|  1.03k|    ) -> Result<ConfigHandle<T>, String> {
  274|  1.03k|        let id = self.next_id.fetch_add(1, Ordering::Relaxed);
  275|  1.03k|        let entry = ConfigEntry::new(data);
  276|  1.03k|        let data_size = entry.data_size;
  277|       |
  278|  1.03k|        self.entries.insert(id, entry);
  279|       |
  280|       |        // Update statistics
  281|  1.03k|        {
  282|  1.03k|            let mut stats = self.stats.write();
  283|  1.03k|            stats.increment_creates();
  284|  1.03k|            stats.add_memory(data_size as u64);
  285|  1.03k|        }
  286|       |
  287|  1.03k|        Ok(ConfigHandle::new(id))
  288|  1.03k|    }
  289|       |
  290|       |    /// Read configuration data
  291|       |    ///
  292|       |    /// Returns `Arc<T>` for efficient sharing. Use field access (`config.host`)
  293|       |    /// and method calls (`config.validate()`) directly - they're zero-cost due to auto-deref.
  294|       |    ///
  295|       |    /// For mutations, create new config and use `update()`.
  296|       |    ///
  297|       |    /// # Errors
  298|       |    ///
  299|       |    /// Returns error message if the handle doesn't exist or points to wrong type.
  300|       |    ///
  301|       |    /// # Performance Notes
  302|       |    ///
  303|       |    /// - Field access: `config.database.host` (zero cost)
  304|       |    /// - Method calls: `config.validate()` (zero cost)
  305|       |    /// - Passing to functions: `process(config)` (~1ns to move Arc)
  306|       |    /// - Multiple reads share the same underlying data efficiently
  307|       |    ///
  308|       |    /// # Examples
  309|       |    ///
  310|       |    /// ```
  311|       |    /// use superconfig::ConfigRegistry;
  312|       |    ///
  313|       |    /// let registry = ConfigRegistry::new();
  314|       |    /// let handle = registry.create("test".to_string()).unwrap();
  315|       |    /// let data = registry.read(&handle).unwrap();
  316|       |    /// assert_eq!(*data, "test");
  317|       |    /// ```
  318|       |    #[generate_json_helper(auto)]
  319|  1.03k|    pub fn read<T: 'static>(&self, handle: &ConfigHandle<T>) -> Result<Arc<T>, String> {
  320|  1.03k|        let entry_ref = self.entries.get(&handle.id()).ok_or_else(|| {
                          ^1.02k                                                   ^4
  321|      4|            let error_msg = format!("superconfig.registry: Handle {} not found", handle.id());
  322|      4|            error!(target: "superconfig.registry", "Handle {} not found", handle.id());
                                         ^0                      ^0                     ^0     ^0
  323|      4|            error_msg
  324|      4|        })?;
  325|       |
  326|       |        // Update statistics
  327|  1.02k|        {
  328|  1.02k|            let mut stats = self.stats.write();
  329|  1.02k|            stats.increment_reads();
  330|  1.02k|        }
  331|       |
  332|  1.02k|        entry_ref.get_arc_data::<T>()
  333|  1.03k|    }
  334|       |
  335|       |
  336|       |    /// Update data in a configuration handle
  337|       |    ///
  338|       |    /// This replaces the entire configuration data with new data.
  339|       |    /// Any existing Arc references will continue to point to the old data.
  340|       |    ///
  341|       |    /// # Errors
  342|       |    ///
  343|       |    /// Returns error message if the handle doesn't exist in the registry.
  344|       |    ///
  345|       |    /// # Examples
  346|       |    ///
  347|       |    /// ```
  348|       |    /// use superconfig::ConfigRegistry;
  349|       |    ///
  350|       |    /// let registry = ConfigRegistry::new();
  351|       |    /// let handle = registry.create("old".to_string()).unwrap();
  352|       |    ///
  353|       |    /// registry.update(&handle, "new".to_string()).unwrap();
  354|       |    /// let data = registry.read(&handle).unwrap();
  355|       |    /// assert_eq!(*data, "new");
  356|       |    /// ```
  357|    507|    pub fn update<T: 'static + Send + Sync>(
  358|    507|        &self,
  359|    507|        handle: &ConfigHandle<T>,
  360|    507|        new_data: T,
  361|    507|    ) -> Result<(), String> {
  362|       |        // Remove old entry to get its size
  363|    507|        let old_entry = self.entries.remove(&handle.id()).ok_or_else(|| {
                          ^505                                                        ^2
  364|      2|            let error_msg = format!("superconfig.registry: Handle {} not found for update", handle.id());
  365|      2|            error!(target: "superconfig.registry", "Handle {} not found for update", handle.id());
                                         ^0                      ^0                                ^0     ^0
  366|      2|            error_msg
  367|      2|        })?;
  368|       |
  369|    505|        let old_size = old_entry.1.data_size;
  370|       |
  371|       |        // Create new entry with new data
  372|    505|        let new_entry = ConfigEntry::new(new_data);
  373|    505|        let new_size = new_entry.data_size;
  374|       |
  375|       |        // Insert new entry (this atomically replaces the old one)
  376|    505|        self.entries.insert(handle.id(), new_entry);
  377|       |
  378|       |        // Update statistics
  379|    505|        {
  380|    505|            let mut stats = self.stats.write();
  381|    505|            stats.increment_updates();
  382|    505|            stats.remove_memory(old_size as u64);
  383|    505|            stats.add_memory(new_size as u64);
  384|    505|        }
  385|       |
  386|    505|        Ok(())
  387|    507|    }
  388|       |
  389|       |    /// Delete a configuration entry and return the data as Arc<T>
  390|       |    ///
  391|       |    /// Returns the same Arc<T> that was stored internally, avoiding any cloning.
  392|       |    /// This is consistent with our zero-copy design philosophy.
  393|       |    ///
  394|       |    /// # Errors
  395|       |    ///
  396|       |    /// Returns error message if the handle doesn't exist or points to wrong type.
  397|       |    ///
  398|       |    /// # Examples
  399|       |    ///
  400|       |    /// ```
  401|       |    /// use superconfig::ConfigRegistry;
  402|       |    ///
  403|       |    /// let registry = ConfigRegistry::new();
  404|       |    /// let handle = registry.create("test".to_string()).unwrap();
  405|       |    ///
  406|       |    /// let data = registry.delete(&handle).unwrap();
  407|       |    /// assert_eq!(*data, "test");
  408|       |    /// assert!(!registry.contains_handle(&handle));
  409|       |    /// ```
  410|    353|    pub fn delete<T: 'static>(&self, handle: &ConfigHandle<T>) -> Result<Arc<T>, String> {
  411|    353|        let (_, entry) = self.entries.remove(&handle.id()).ok_or_else(|| {
                              ^351                                                     ^2
  412|      2|            let error_msg = format!("superconfig.registry: Handle {} not found for delete", handle.id());
  413|      2|            error!(target: "superconfig.registry", "Handle {} not found for delete", handle.id());
                                         ^0                      ^0                                ^0     ^0
  414|      2|            error_msg
  415|      2|        })?;
  416|       |
  417|    351|        let data_size = entry.data_size;
  418|       |
  419|       |        // Extract the Arc<T> directly
  420|    351|        let arc = entry.data.downcast::<Arc<T>>().map_err(|_| {
                          ^348                                              ^3
  421|      3|            let error_msg = format!("superconfig.registry: Wrong type for delete, expected {}, found {}", std::any::type_name::<T>(), entry.type_name);
  422|      3|            error!(target: "superconfig.registry", "Wrong type for delete, expected {}, found {}", std::any::type_name::<T>(), entry.type_name);
                                         ^0                      ^0                                              ^0
  423|      3|            error_msg
  424|      3|        })?;
  425|       |
  426|       |        // Update statistics
  427|    348|        {
  428|    348|            let mut stats = self.stats.write();
  429|    348|            stats.increment_deletes();
  430|    348|            stats.remove_memory(data_size as u64);
  431|    348|        }
  432|       |
  433|    348|        Ok(*arc)
  434|    353|    }
  435|       |
  436|       |    /// Get current registry statistics
  437|       |    ///
  438|       |    /// # Examples
  439|       |    ///
  440|       |    /// ```
  441|       |    /// use superconfig::ConfigRegistry;
  442|       |    ///
  443|       |    /// let registry = ConfigRegistry::new();
  444|       |    /// let stats = registry.stats();
  445|       |    /// assert_eq!(stats.total_handles, 0);
  446|       |    /// ```
  447|       |    #[must_use]
  448|     11|    pub fn stats(&self) -> RegistryStats {
  449|     11|        self.stats.read().clone()
  450|     11|    }
  451|       |
  452|       |    /// Check if a handle exists in the registry
  453|       |    ///
  454|       |    /// # Examples
  455|       |    ///
  456|       |    /// ```
  457|       |    /// use superconfig::ConfigRegistry;
  458|       |    ///
  459|       |    /// let registry = ConfigRegistry::new();
  460|       |    /// let handle = registry.create("test".to_string()).unwrap();
  461|       |    ///
  462|       |    /// assert!(registry.contains_handle(&handle));
  463|       |    /// registry.delete(&handle).unwrap();
  464|       |    /// assert!(!registry.contains_handle(&handle));
  465|       |    /// ```
  466|       |    #[must_use]
  467|      2|    pub fn contains_handle<T>(&self, handle: &ConfigHandle<T>) -> bool {
  468|      2|        self.entries.contains_key(&handle.id())
  469|      2|    }
  470|       |
  471|       |    /// Clear all entries from the registry
  472|       |    ///
  473|       |    /// # Examples
  474|       |    ///
  475|       |    /// ```
  476|       |    /// use superconfig::ConfigRegistry;
  477|       |    ///
  478|       |    /// let registry = ConfigRegistry::new();
  479|       |    /// let _handle = registry.create("test".to_string()).unwrap();
  480|       |    ///
  481|       |    /// assert_eq!(registry.len(), 1);
  482|       |    /// registry.clear();
  483|       |    /// assert_eq!(registry.len(), 0);
  484|       |    /// ```
  485|      1|    pub fn clear(&self) {
  486|      1|        self.entries.clear();
  487|      1|        let mut stats = self.stats.write();
  488|      1|        stats.reset();
  489|      1|    }
  490|       |
  491|       |    /// Get the number of entries in the registry
  492|       |    ///
  493|       |    /// # Examples
  494|       |    ///
  495|       |    /// ```
  496|       |    /// use superconfig::ConfigRegistry;
  497|       |    ///
  498|       |    /// let registry = ConfigRegistry::new();
  499|       |    /// assert_eq!(registry.len(), 0);
  500|       |    ///
  501|       |    /// let _handle = registry.create("test".to_string()).unwrap();
  502|       |    /// assert_eq!(registry.len(), 1);
  503|       |    /// ```
  504|       |    #[must_use]
  505|      2|    pub fn len(&self) -> usize {
  506|      2|        self.entries.len()
  507|      2|    }
  508|       |
  509|       |    /// Check if the registry is empty
  510|       |    ///
  511|       |    /// # Examples
  512|       |    ///
  513|       |    /// ```
  514|       |    /// use superconfig::ConfigRegistry;
  515|       |    ///
  516|       |    /// let registry = ConfigRegistry::new();
  517|       |    /// assert!(registry.is_empty());
  518|       |    ///
  519|       |    /// let _handle = registry.create("test".to_string()).unwrap();
  520|       |    /// assert!(!registry.is_empty());
  521|       |    /// ```
  522|       |    #[must_use]
  523|      2|    pub fn is_empty(&self) -> bool {
  524|      2|        self.entries.is_empty()
  525|      2|    }
  526|       |
  527|       |}
  528|       |
  529|       |// Global registry instance - defined here to be close to the implementation
  530|       |/// Global configuration registry instance
  531|       |static GLOBAL_REGISTRY: std::sync::LazyLock<Arc<ConfigRegistry>> =
  532|       |    std::sync::LazyLock::new(ConfigRegistry::new);
  533|       |
  534|       |/// Get a reference to the global configuration registry
  535|       |///
  536|       |/// # Examples
  537|       |///
  538|       |/// ```
  539|       |/// use superconfig::global_registry;
  540|       |///
  541|       |/// let handle = global_registry().create("test".to_string()).unwrap();
  542|       |/// let data = global_registry().read(&handle).unwrap();
  543|       |/// assert_eq!(*data, "test");
  544|       |/// ```
  545|       |#[must_use]
  546|      2|pub fn global_registry() -> &'static Arc<ConfigRegistry> {
  547|      2|    &GLOBAL_REGISTRY
  548|      2|}
  549|       |
  550|       |#[cfg(test)]
  551|       |mod tests {
  552|       |    use super::*;
  553|       |    use crate::config_flags::{runtime, startup};
  554|       |    use serde::{Deserialize, Serialize};
  555|       |    use std::sync::atomic::{AtomicU32, Ordering};
  556|       |    use std::thread;
  557|       |
  558|       |    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
  559|       |    struct TestConfig {
  560|       |        host: String,
  561|       |        port: u16,
  562|       |        timeout_ms: u32,
  563|       |    }
  564|       |
  565|       |    #[derive(Debug, Clone, PartialEq, Serialize)]
  566|       |    struct SimpleConfig {
  567|       |        value: i32,
  568|       |    }
  569|       |
  570|       |    #[test]
  571|      1|    fn test_create_and_read() {
  572|      1|        let registry = ConfigRegistry::new();
  573|      1|        let config = TestConfig {
  574|      1|            host: "localhost".to_string(),
  575|      1|            port: 8080,
  576|      1|            timeout_ms: 5000,
  577|      1|        };
  578|       |
  579|      1|        let handle = registry.create(config.clone()).unwrap();
  580|      1|        let retrieved = registry.read(&handle).unwrap();
  581|       |
  582|      1|        assert_eq!(*retrieved, config);
  583|      1|        assert_eq!(handle.id(), 1);
  584|      1|    }
  585|       |
  586|       |    #[test]
  587|      1|    fn test_flag_operations() {
  588|      1|        let registry = ConfigRegistry::custom(startup::SIMD | startup::THREAD_POOL)
  589|      1|            .enable(runtime::STRICT_MODE | runtime::PARALLEL);
  590|       |
  591|       |        // Test startup flags
  592|      1|        assert!(registry.startup_enabled(startup::SIMD));
  593|      1|        assert!(registry.startup_enabled(startup::THREAD_POOL));
  594|      1|        assert!(!registry.startup_enabled(startup::DETAILED_STATS));
  595|      1|        assert!(registry.startup_disabled(startup::DETAILED_STATS));
  596|       |
  597|       |        // Test runtime flags
  598|      1|        assert!(registry.runtime_enabled(runtime::STRICT_MODE));
  599|      1|        assert!(registry.runtime_enabled(runtime::PARALLEL));
  600|      1|        assert!(!registry.runtime_enabled(runtime::ARRAY_MERGE));
  601|      1|        assert!(registry.runtime_disabled(runtime::ARRAY_MERGE));
  602|       |
  603|       |        // Test runtime flag modification
  604|      1|        let registry = registry.enable(runtime::ARRAY_MERGE);
  605|      1|        assert!(registry.runtime_enabled(runtime::ARRAY_MERGE));
  606|       |
  607|      1|        let registry = registry.disable(runtime::PARALLEL);
  608|      1|        assert!(!registry.runtime_enabled(runtime::PARALLEL));
  609|      1|    }
  610|       |
  611|       |    #[test]
  612|      1|    fn test_update() {
  613|      1|        let registry = ConfigRegistry::new();
  614|      1|        let original = TestConfig {
  615|      1|            host: "localhost".to_string(),
  616|      1|            port: 8080,
  617|      1|            timeout_ms: 5000,
  618|      1|        };
  619|      1|        let updated = TestConfig {
  620|      1|            host: "remote".to_string(),
  621|      1|            port: 9090,
  622|      1|            timeout_ms: 10000,
  623|      1|        };
  624|       |
  625|      1|        let handle = registry.create(original).unwrap();
  626|       |
  627|       |        // Keep a reference to the old data
  628|      1|        let old_data = registry.read(&handle).unwrap();
  629|       |
  630|      1|        registry.update(&handle, updated.clone()).unwrap();
  631|      1|        let new_data = registry.read(&handle).unwrap();
  632|       |
  633|       |        // New data should be updated
  634|      1|        assert_eq!(*new_data, updated);
  635|       |
  636|       |        // Old Arc reference should still point to original data
  637|      1|        assert_eq!(old_data.host, "localhost");
  638|      1|        assert_eq!(old_data.port, 8080);
  639|      1|    }
  640|       |
  641|       |    #[test]
  642|      1|    fn test_delete() {
  643|      1|        let registry = ConfigRegistry::new();
  644|      1|        let config = TestConfig {
  645|      1|            host: "localhost".to_string(),
  646|      1|            port: 8080,
  647|      1|            timeout_ms: 5000,
  648|      1|        };
  649|       |
  650|      1|        let handle = registry.create(config.clone()).unwrap();
  651|      1|        let deleted = registry.delete(&handle).unwrap();
  652|       |
  653|      1|        assert_eq!(*deleted, config);
  654|       |
  655|       |        // Handle should no longer exist
  656|      1|        assert!(!registry.contains_handle(&handle));
  657|      1|        assert!(registry.read(&handle).is_err());
  658|      1|    }
  659|       |
  660|       |    #[test]
  661|      1|    fn test_invalid_handle_operations() {
  662|      1|        let registry = ConfigRegistry::new();
  663|       |        
  664|       |        // Test various error scenarios that can occur during normal operations
  665|       |        
  666|       |        // Scenario 1: Delete with non-existent handle
  667|      1|        let phantom_delete_handle = ConfigHandle::<TestConfig>::new(999);
  668|      1|        let result = registry.delete(&phantom_delete_handle);
  669|      1|        assert!(result.is_err());
  670|      1|        assert!(result.unwrap_err().contains("Handle 999 not found for delete"));
  671|       |        
  672|       |        // Scenario 2: Update with non-existent handle  
  673|      1|        let phantom_config = TestConfig {
  674|      1|            host: "phantom".to_string(),
  675|      1|            port: 888,
  676|      1|            timeout_ms: 5000,
  677|      1|        };
  678|      1|        let phantom_update_handle = ConfigHandle::<TestConfig>::new(888);
  679|      1|        let result = registry.update(&phantom_update_handle, phantom_config);
  680|      1|        assert!(result.is_err());
  681|      1|        assert!(result.unwrap_err().contains("Handle 888 not found for update"));
  682|       |        
  683|       |        // Scenario 3: Read with non-existent handle for different type
  684|      1|        let phantom_string_handle = ConfigHandle::<String>::new(777);
  685|      1|        let result = registry.read(&phantom_string_handle);
  686|      1|        assert!(result.is_err());
  687|      1|        assert!(result.unwrap_err().contains("Handle 777 not found"));
  688|       |        
  689|      1|        println!(" Invalid handle operations: all error paths covered comprehensively");
  690|      1|    }
  691|       |
  692|       |    #[test]
  693|      1|    fn test_wrong_type() {
  694|      1|        let registry = ConfigRegistry::new();
  695|      1|        let config = TestConfig {
  696|      1|            host: "localhost".to_string(),
  697|      1|            port: 8080,
  698|      1|            timeout_ms: 5000,
  699|      1|        };
  700|       |
  701|      1|        let handle = registry.create(config).unwrap();
  702|       |
  703|       |        // Try to read as wrong type by manually creating handle with wrong type
  704|      1|        let wrong_handle = ConfigHandle::<SimpleConfig>::new(handle.id());
  705|      1|        let result = registry.read(&wrong_handle);
  706|       |
  707|      1|        assert!(result.is_err());
  708|      1|        let error_msg = result.unwrap_err();
  709|      1|        assert!(error_msg.contains("Wrong type"));
  710|      1|        assert!(error_msg.contains("expected"));
  711|      1|        assert!(error_msg.contains("found"));
  712|      1|    }
  713|       |
  714|       |    #[test]
  715|      1|    fn test_statistics() {
  716|      1|        let registry = ConfigRegistry::new();
  717|      1|        let config1 = TestConfig {
  718|      1|            host: "localhost".to_string(),
  719|      1|            port: 8080,
  720|      1|            timeout_ms: 5000,
  721|      1|        };
  722|      1|        let config2 = SimpleConfig { value: 42 };
  723|       |
  724|       |        // Initial stats
  725|      1|        let stats = registry.stats();
  726|      1|        assert_eq!(stats.total_handles, 0);
  727|      1|        assert_eq!(stats.total_creates, 0);
  728|      1|        assert_eq!(stats.total_reads, 0);
  729|       |
  730|       |        // Create operations
  731|      1|        let handle1 = registry.create(config1).unwrap();
  732|      1|        let handle2 = registry.create(config2).unwrap();
  733|       |
  734|      1|        let stats = registry.stats();
  735|      1|        assert_eq!(stats.total_handles, 2);
  736|      1|        assert_eq!(stats.total_creates, 2);
  737|      1|        assert!(stats.memory_usage_bytes > 0);
  738|       |
  739|       |        // Read operations
  740|      1|        let _data1 = registry.read(&handle1).unwrap();
  741|      1|        let _data2 = registry.read(&handle2).unwrap();
  742|       |
  743|      1|        let stats = registry.stats();
  744|      1|        assert_eq!(stats.total_reads, 2);
  745|       |
  746|       |        // Update operation
  747|      1|        registry
  748|      1|            .update(
  749|      1|                &handle1,
  750|      1|                TestConfig {
  751|      1|                    host: "updated".to_string(),
  752|      1|                    port: 9090,
  753|      1|                    timeout_ms: 6000,
  754|      1|                },
  755|      1|            )
  756|      1|            .unwrap();
  757|       |
  758|      1|        let stats = registry.stats();
  759|      1|        assert_eq!(stats.total_updates, 1);
  760|       |
  761|       |        // Delete operation
  762|      1|        registry.delete(&handle2).unwrap();
  763|       |
  764|      1|        let stats = registry.stats();
  765|      1|        assert_eq!(stats.total_handles, 1);
  766|      1|        assert_eq!(stats.total_deletes, 1);
  767|      1|    }
  768|       |
  769|       |    #[test]
  770|      1|    fn test_concurrent_access() {
  771|      1|        let registry = Arc::new(ConfigRegistry::new());
  772|      1|        let counter = Arc::new(AtomicU32::new(0));
  773|      1|        let num_threads = 10;
  774|      1|        let operations_per_thread = 100;
  775|       |
  776|      1|        let mut handles = vec![];
  777|       |
  778|       |        // Spawn threads for concurrent operations
  779|      1|        for _ in 0..num_threads {
  780|     10|            let registry_clone = Arc::clone(&registry);
  781|     10|            let counter_clone = Arc::clone(&counter);
  782|       |
  783|     10|            let handle = thread::spawn(move || {
  784|  1.00k|                for i in 0..operations_per_thread {
                                          ^10
  785|  1.00k|                    let config = SimpleConfig {
  786|  1.00k|                        value: counter_clone.fetch_add(1, Ordering::Relaxed) as i32,
  787|  1.00k|                    };
  788|       |
  789|  1.00k|                    let handle = registry_clone.create(config).unwrap();
  790|  1.00k|                    let _data = registry_clone.read(&handle).unwrap();
  791|       |
  792|  1.00k|                    if i % 2 == 0 {
  793|    500|                        registry_clone
  794|    500|                            .update(&handle, SimpleConfig { value: -1 })
  795|    500|                            .unwrap();
  796|    500|                    }
  797|       |
  798|  1.00k|                    if i % 3 == 0 {
  799|    340|                        let _deleted = registry_clone.delete(&handle).unwrap();
  800|    660|                    }
  801|       |                }
  802|     10|            });
  803|     10|            handles.push(handle);
  804|       |        }
  805|       |
  806|       |        // Wait for all threads to complete
  807|     11|        for handle in handles {
                          ^10
  808|     10|            handle.join().unwrap();
  809|     10|        }
  810|       |
  811|      1|        let stats = registry.stats();
  812|      1|        assert_eq!(
  813|       |            stats.total_creates,
  814|      1|            (num_threads * operations_per_thread) as u64
  815|       |        );
  816|      1|        assert!(stats.total_reads >= (num_threads * operations_per_thread) as u64);
  817|      1|    }
  818|       |
  819|       |    #[test]
  820|      1|    fn test_global_registry() {
  821|      1|        let config = SimpleConfig { value: 123 };
  822|       |
  823|      1|        let handle = global_registry().create(config.clone()).unwrap();
  824|      1|        let retrieved = global_registry().read(&handle).unwrap();
  825|       |
  826|      1|        assert_eq!(*retrieved, config);
  827|      1|    }
  828|       |
  829|       |    #[test]
  830|      1|    fn test_arc_sharing() {
  831|      1|        let registry = ConfigRegistry::new();
  832|      1|        let config = TestConfig {
  833|      1|            host: "localhost".to_string(),
  834|      1|            port: 8080,
  835|      1|            timeout_ms: 5000,
  836|      1|        };
  837|       |
  838|      1|        let handle = registry.create(config).unwrap();
  839|       |
  840|       |        // Multiple reads should return the same underlying data
  841|      1|        let arc1 = registry.read(&handle).unwrap();
  842|      1|        let arc2 = registry.read(&handle).unwrap();
  843|       |
  844|       |        // They should be the same Arc (same pointer)
  845|      1|        assert!(Arc::ptr_eq(&arc1, &arc2));
  846|       |
  847|       |        // Verify we can access data through both
  848|      1|        assert_eq!(arc1.host, "localhost");
  849|      1|        assert_eq!(arc2.port, 8080);
  850|      1|    }
  851|       |
  852|       |    #[test]
  853|      1|    fn test_memory_cleanup() {
  854|      1|        let registry = ConfigRegistry::new();
  855|      1|        let config = TestConfig {
  856|      1|            host: "localhost".to_string(),
  857|      1|            port: 8080,
  858|      1|            timeout_ms: 5000,
  859|      1|        };
  860|       |
  861|      1|        let handle = registry.create(config).unwrap();
  862|      1|        let initial_memory = registry.stats().memory_usage_bytes;
  863|       |
  864|       |        // Delete should reduce memory usage
  865|      1|        let _deleted = registry.delete(&handle).unwrap();
  866|      1|        let final_memory = registry.stats().memory_usage_bytes;
  867|       |
  868|      1|        assert!(final_memory < initial_memory);
  869|      1|    }
  870|       |
  871|       |    #[test]
  872|      1|    fn test_clear_registry() {
  873|      1|        let registry = ConfigRegistry::new();
  874|       |
  875|       |        // Add some entries
  876|      1|        let _handle1 = registry.create(SimpleConfig { value: 1 }).unwrap();
  877|      1|        let _handle2 = registry.create(SimpleConfig { value: 2 }).unwrap();
  878|       |
  879|      1|        assert_eq!(registry.len(), 2);
  880|      1|        assert!(!registry.is_empty());
  881|       |
  882|       |        // Clear registry
  883|      1|        registry.clear();
  884|       |
  885|      1|        assert_eq!(registry.len(), 0);
  886|      1|        assert!(registry.is_empty());
  887|       |
  888|      1|        let stats = registry.stats();
  889|      1|        assert_eq!(stats.total_handles, 0);
  890|      1|        assert_eq!(stats.memory_usage_bytes, 0);
  891|      1|    }
  892|       |
  893|       |    #[test]
  894|      1|    fn test_handle_id_generation() {
  895|      1|        let registry = ConfigRegistry::new();
  896|       |
  897|      1|        let handle1 = registry.create(SimpleConfig { value: 1 }).unwrap();
  898|      1|        let handle2 = registry.create(SimpleConfig { value: 2 }).unwrap();
  899|      1|        let handle3 = registry.create(SimpleConfig { value: 3 }).unwrap();
  900|       |
  901|       |        // IDs should be sequential and unique
  902|      1|        assert_eq!(handle1.id(), 1);
  903|      1|        assert_eq!(handle2.id(), 2);
  904|      1|        assert_eq!(handle3.id(), 3);
  905|       |
  906|       |        // Delete one and create another - should get next ID
  907|      1|        registry.delete(&handle2).unwrap();
  908|      1|        let handle4 = registry.create(SimpleConfig { value: 4 }).unwrap();
  909|      1|        assert_eq!(handle4.id(), 4);
  910|      1|    }
  911|       |
  912|       |    #[test]
  913|      1|    fn test_builder_pattern() {
  914|      1|        let registry = ConfigRegistry::custom(startup::SIMD).enable(runtime::STRICT_MODE);
  915|       |
  916|      1|        assert!(registry.startup_enabled(startup::SIMD));
  917|      1|        assert!(registry.runtime_enabled(runtime::STRICT_MODE));
  918|      1|    }
  919|       |
  920|       |    /// Test the macro-generated `enable_as_json` method
  921|       |    #[test]
  922|      1|    fn test_macro_generated_enable_as_json() {
  923|       |        use crate::config_flags::runtime;
  924|       |
  925|       |        // Test success case
  926|      1|        let registry = ConfigRegistry::new();
  927|      1|        let result = registry.enable_as_json(runtime::STRICT_MODE);
  928|       |
  929|      1|        println!(" Macro-generated enable_as_json result: {result}");
  930|       |
  931|       |        // Parse the JSON response
  932|      1|        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();
  933|       |
  934|       |        // Verify the structure matches handle_mode expectations
  935|      1|        assert_eq!(parsed["success"], true);
  936|       |        // In handle_mode, there should be NO data field - only success
  937|      1|        assert!(parsed.get("data").is_none());
  938|      1|        assert!(parsed.get("error").is_none());
  939|       |
  940|       |        // Should have exactly one field: "success"
  941|      1|        assert_eq!(parsed.as_object().unwrap().len(), 1);
  942|       |
  943|      1|        println!(" Success: JSON structure is correct for handle_mode");
  944|      1|        println!("   - success: {}", parsed["success"]);
  945|      1|        println!("   - data field absent: {}", parsed.get("data").is_none());
  946|      1|        println!("   - error field absent: {}", parsed.get("error").is_none());
  947|       |
  948|       |        // Verify the exact JSON matches our expectations
  949|      1|        let expected_json = r#"{"success":true}"#;
  950|      1|        let normalized_result = result.replace(' ', ""); // Remove any whitespace
  951|      1|        assert_eq!(normalized_result, expected_json);
  952|       |
  953|      1|        println!(" JSON output matches expected format exactly");
  954|      1|    }
  955|       |
  956|       |
  957|       |    // Old try_enable tests removed - replaced by Arc-based tests below
  958|       |
  959|       |    /// Test the macro-generated `enable_as_json` method error case
  960|       |    #[test]
  961|      1|    fn test_macro_generated_enable_as_json_error() {
  962|       |        // Test error case - enable method doesn't typically fail with invalid flags,
  963|       |        // but let's test with a scenario that would normally cause an error
  964|      1|        let registry = ConfigRegistry::new();
  965|       |
  966|       |        // Use a valid flag since enable method validates flags internally
  967|      1|        let result = registry.enable_as_json(runtime::STRICT_MODE);
  968|       |
  969|      1|        println!(" Macro-generated enable_as_json result: {result}");
  970|       |
  971|       |        // Parse the JSON response
  972|      1|        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();
  973|       |
  974|       |        // Should still be success since STRICT_MODE is a valid flag
  975|      1|        assert_eq!(parsed["success"], true);
  976|      1|        assert!(parsed.get("data").is_none()); // Handle mode - no data
  977|      1|        assert!(parsed.get("error").is_none()); // No error for valid flag
  978|       |
  979|      1|        println!(" Handle mode correctly returns success without data serialization");
  980|       |
  981|       |        // Note: The enable method in SuperConfig doesn't typically fail,
  982|       |        // but if it did, handle_mode would return {"success": false, "error": "message"}
  983|       |        // The error handling is tested in the macro crate's comprehensive tests
  984|      1|    }
  985|       |
  986|       |    // ===== Arc-based chaining pattern tests =====
  987|       |
  988|       |    /// Test enable success case
  989|       |    #[test]
  990|      1|    fn test_enable_success() {
  991|       |        use crate::config_flags::runtime;
  992|       |
  993|      1|        let registry = ConfigRegistry::new();
  994|       |
  995|       |        // Should not panic and should enable the flag
  996|      1|        let result = registry.enable(runtime::STRICT_MODE);
  997|       |
  998|       |        // Verify the flag was actually enabled
  999|      1|        assert!(result.runtime_enabled(runtime::STRICT_MODE));
 1000|       |
 1001|       |        // Registry continues chain successfully
 1002|       |
 1003|      1|        println!(" Enable success: flag enabled correctly");
 1004|      1|    }
 1005|       |
 1006|       |    /// Test enable with invalid flag (error handling)
 1007|       |    #[test]
 1008|      1|    fn test_enable_error_handling() {
 1009|      1|        let registry = ConfigRegistry::new();
 1010|       |
 1011|       |        // Use an invalid flag that should cause a logffi error but continue chain
 1012|      1|        let result = registry.enable(0xFFFFFFFF); // Invalid flag
 1013|       |
 1014|       |        // Should continue chain even with invalid flag
 1015|       |        // The error is logged but chain continues
 1016|       |        
 1017|       |        // Verify registry still works after invalid flag
 1018|      1|        let handle = result.create("test".to_string()).unwrap();
 1019|      1|        let data = result.read(&handle).unwrap();
 1020|      1|        assert_eq!(*data, "test");
 1021|       |
 1022|      1|        println!(" Enable error handling: invalid flag handled gracefully");
 1023|      1|    }
 1024|       |
 1025|       |    /// Test enable method chaining
 1026|       |    #[test]
 1027|      1|    fn test_enable_method_chaining() {
 1028|       |        use crate::config_flags::runtime;
 1029|       |
 1030|      1|        let registry = ConfigRegistry::new();
 1031|       |
 1032|       |        // Chain multiple enable calls
 1033|      1|        let result = registry
 1034|      1|            .enable(runtime::STRICT_MODE)
 1035|      1|            .enable(runtime::PARALLEL)
 1036|      1|            .enable(runtime::ENV_EXPANSION);
 1037|       |
 1038|       |        // Verify all flags were enabled
 1039|      1|        assert!(result.runtime_enabled(runtime::STRICT_MODE));
 1040|      1|        assert!(result.runtime_enabled(runtime::PARALLEL));
 1041|      1|        assert!(result.runtime_enabled(runtime::ENV_EXPANSION));
 1042|       |
 1043|       |        // All flags enabled successfully
 1044|       |
 1045|      1|        println!(" Enable chaining: all flags enabled correctly");
 1046|      1|    }
 1047|       |
 1048|       |    /// Test mixed chaining with enable and disable
 1049|       |    #[test]
 1050|      1|    fn test_enable_disable_chaining() {
 1051|       |        use crate::config_flags::runtime;
 1052|       |
 1053|      1|        let registry = ConfigRegistry::new();
 1054|       |
 1055|       |        // Chain enable and disable operations
 1056|      1|        let result = registry
 1057|      1|            .enable(runtime::STRICT_MODE)
 1058|      1|            .enable(runtime::PARALLEL)
 1059|      1|            .disable(runtime::STRICT_MODE);
 1060|       |
 1061|       |        // Verify the final state
 1062|      1|        assert!(!result.runtime_enabled(runtime::STRICT_MODE)); // Disabled
 1063|      1|        assert!(result.runtime_enabled(runtime::PARALLEL)); // Still enabled
 1064|       |
 1065|      1|        println!(" Enable/disable chaining: methods work together");
 1066|      1|    }
 1067|       |
 1068|       |    /// Test catch and errors methods
 1069|       |    #[test]
 1070|      1|    fn test_arc_catch_and_errors() {
 1071|      1|        let registry = ConfigRegistry::new();
 1072|       |
 1073|       |        // Test valid operations work correctly
 1074|      1|        let registry = registry.enable(crate::config_flags::runtime::STRICT_MODE);
 1075|       |        
 1076|       |        // Verify flag was enabled
 1077|      1|        assert!(registry.runtime_enabled(crate::config_flags::runtime::STRICT_MODE));
 1078|       |
 1079|      1|        println!(" Arc operations: methods work correctly");
 1080|      1|    }
 1081|       |
 1082|       |    /// Test registry creation methods
 1083|       |    #[test]
 1084|      1|    fn test_registry_creation_methods() {
 1085|       |        use crate::config_flags::startup;
 1086|       |
 1087|       |        // Test new
 1088|      1|        let registry1 = ConfigRegistry::new();
 1089|      1|        assert_eq!(registry1.get_startup_flags(), 0);
 1090|       |
 1091|       |        // Test custom
 1092|      1|        let registry2 = ConfigRegistry::custom(startup::SIMD | startup::THREAD_POOL);
 1093|      1|        assert!(registry2.startup_enabled(startup::SIMD));
 1094|      1|        assert!(registry2.startup_enabled(startup::THREAD_POOL));
 1095|       |
 1096|       |        // Verify both are Arc<ConfigRegistry>
 1097|      1|        let _: std::sync::Arc<ConfigRegistry> = registry1;
 1098|      1|        let _: std::sync::Arc<ConfigRegistry> = registry2;
 1099|       |
 1100|      1|        println!(" Registry creation methods: new and custom work correctly");
 1101|      1|    }
 1102|       |
 1103|       |    /// Test registry reference behavior
 1104|       |    #[test]
 1105|      1|    fn test_registry_reference_behavior() {
 1106|       |        use crate::config_flags::runtime;
 1107|       |
 1108|      1|        let registry1 = ConfigRegistry::new();
 1109|      1|        let registry2 = Arc::clone(&registry1);
 1110|       |
 1111|       |        // Both references should work
 1112|      1|        let result1 = registry1.enable(runtime::STRICT_MODE);
 1113|      1|        let result2 = registry2.enable(runtime::PARALLEL);
 1114|       |
 1115|       |        // They should point to the same registry
 1116|      1|        assert!(Arc::ptr_eq(&result1, &result2));
 1117|       |
 1118|       |        // Both flags should be visible from either reference
 1119|      1|        assert!(result1.runtime_enabled(runtime::STRICT_MODE));
 1120|      1|        assert!(result1.runtime_enabled(runtime::PARALLEL));
 1121|      1|        assert!(result2.runtime_enabled(runtime::STRICT_MODE));
 1122|      1|        assert!(result2.runtime_enabled(runtime::PARALLEL));
 1123|       |
 1124|      1|        println!(" Registry reference behavior: shared state works correctly");
 1125|      1|    }
 1126|       |
 1127|       |    #[test]
 1128|      1|    fn test_enable_as_json_success() {
 1129|       |        use crate::config_flags::runtime;
 1130|       |
 1131|      1|        let registry = ConfigRegistry::new();
 1132|      1|        let json_result = registry.enable_as_json(runtime::STRICT_MODE);
 1133|       |
 1134|      1|        let result: serde_json::Value = serde_json::from_str(&json_result).unwrap();
 1135|      1|        assert_eq!(result["success"], true);
 1136|       |        // handle_mode should not include data field
 1137|      1|        assert!(result.get("data").is_none());
 1138|       |
 1139|      1|        println!(" enable_as_json success: {json_result}");
 1140|      1|    }
 1141|       |
 1142|       |    #[test]
 1143|      1|    fn test_enable_as_json_error() {
 1144|      1|        let registry = ConfigRegistry::new();
 1145|      1|        let json_result = registry.enable_as_json(0xFFFFFFFF); // Invalid flag
 1146|       |
 1147|      1|        let result: serde_json::Value = serde_json::from_str(&json_result).unwrap();
 1148|      1|        assert_eq!(result["success"], true); // Should still be true since our enable method continues chain
 1149|       |
 1150|      1|        println!(" enable_as_json with invalid flag: {json_result}");
 1151|      1|    }
 1152|       |
 1153|       |    #[test]
 1154|      1|    fn test_enable_as_json_with_chaining() {
 1155|       |        use crate::config_flags::runtime;
 1156|       |
 1157|      1|        let registry = ConfigRegistry::new();
 1158|       |
 1159|       |        // Test that the enable method works for chaining
 1160|      1|        let registry = registry.enable(runtime::STRICT_MODE);
 1161|       |
 1162|       |        // Clone registry before the move
 1163|      1|        let registry_clone = Arc::clone(&registry);
 1164|       |
 1165|       |        // Test that JSON helper works after chaining
 1166|      1|        let json_result = registry.enable_as_json(runtime::PARALLEL);
 1167|      1|        let result: serde_json::Value = serde_json::from_str(&json_result).unwrap();
 1168|      1|        assert_eq!(result["success"], true);
 1169|       |
 1170|       |        // Verify flags are enabled using the clone
 1171|      1|        assert!(registry_clone.runtime_enabled(runtime::STRICT_MODE));
 1172|      1|        assert!(registry_clone.runtime_enabled(runtime::PARALLEL));
 1173|       |
 1174|      1|        println!(" enable_as_json chaining: {json_result}");
 1175|      1|    }
 1176|       |
 1177|       |    #[test]
 1178|      1|    fn test_read_as_json_success() {
 1179|      1|        let registry = ConfigRegistry::new();
 1180|      1|        let config = SimpleConfig { value: 42 };
 1181|      1|        let handle = registry.create(config).unwrap();
 1182|       |
 1183|      1|        let json_result = registry.read_as_json(&handle);
 1184|      1|        let result: serde_json::Value = serde_json::from_str(&json_result).unwrap();
 1185|       |
 1186|      1|        assert_eq!(result["success"], true);
 1187|      1|        assert!(result["data"].is_object());
 1188|      1|        assert_eq!(result["data"]["value"], 42);
 1189|       |
 1190|       |        // Should NOT be a string containing JSON
 1191|      1|        assert!(!result["data"].is_string());
 1192|       |
 1193|      1|        println!(" read_as_json success: {json_result}");
 1194|      1|    }
 1195|       |
 1196|       |    #[test]
 1197|      1|    fn test_read_as_json_error() {
 1198|      1|        let registry = ConfigRegistry::new();
 1199|      1|        let invalid_handle = ConfigHandle::<SimpleConfig>::new(999); // Non-existent handle
 1200|       |
 1201|      1|        let json_result = registry.read_as_json(&invalid_handle);
 1202|      1|        let result: serde_json::Value = serde_json::from_str(&json_result).unwrap();
 1203|       |
 1204|      1|        assert_eq!(result["success"], false);
 1205|      1|        assert!(result["error"].is_string());
 1206|      1|        assert!(result["error"].as_str().unwrap().contains("Handle 999 not found"));
 1207|      1|        assert!(result.get("data").is_none());
 1208|       |
 1209|      1|        println!(" read_as_json error: {json_result}");
 1210|      1|    }
 1211|       |
 1212|       |    #[test]
 1213|      1|    fn test_read_as_json_with_string_data() {
 1214|      1|        let registry = ConfigRegistry::new();
 1215|      1|        let config = "test string".to_string();
 1216|      1|        let handle = registry.create(config).unwrap();
 1217|       |
 1218|      1|        let json_result = registry.read_as_json(&handle);
 1219|      1|        let result: serde_json::Value = serde_json::from_str(&json_result).unwrap();
 1220|       |
 1221|      1|        assert_eq!(result["success"], true);
 1222|      1|        assert_eq!(result["data"], "test string");
 1223|      1|        assert!(result["data"].is_string());
 1224|       |
 1225|      1|        println!(" read_as_json string data: {json_result}");
 1226|      1|    }
 1227|       |
 1228|       |    #[test]
 1229|      1|    fn test_read_as_json_with_complex_data() {
 1230|       |        #[derive(Debug, Clone, PartialEq, serde::Serialize)]
 1231|       |        struct ComplexConfig {
 1232|       |            name: String,
 1233|       |            settings: Vec<String>,
 1234|       |            nested: NestedConfig,
 1235|       |        }
 1236|       |
 1237|       |        #[derive(Debug, Clone, PartialEq, serde::Serialize)]
 1238|       |        struct NestedConfig {
 1239|       |            enabled: bool,
 1240|       |            count: u32,
 1241|       |        }
 1242|       |
 1243|      1|        let registry = ConfigRegistry::new();
 1244|      1|        let config = ComplexConfig {
 1245|      1|            name: "test config".to_string(),
 1246|      1|            settings: vec!["opt1".to_string(), "opt2".to_string()],
 1247|      1|            nested: NestedConfig {
 1248|      1|                enabled: true,
 1249|      1|                count: 5,
 1250|      1|            },
 1251|      1|        };
 1252|      1|        let handle = registry.create(config.clone()).unwrap();
 1253|       |
 1254|      1|        let json_result = registry.read_as_json(&handle);
 1255|      1|        let result: serde_json::Value = serde_json::from_str(&json_result).unwrap();
 1256|       |
 1257|      1|        assert_eq!(result["success"], true);
 1258|      1|        assert!(result["data"].is_object());
 1259|      1|        assert_eq!(result["data"]["name"], "test config");
 1260|      1|        assert!(result["data"]["settings"].is_array());
 1261|      1|        assert_eq!(result["data"]["settings"][0], "opt1");
 1262|      1|        assert_eq!(result["data"]["nested"]["enabled"], true);
 1263|      1|        assert_eq!(result["data"]["nested"]["count"], 5);
 1264|       |
 1265|       |        // Test error closure for ComplexConfig - handle not found
 1266|      1|        let fake_handle = ConfigHandle::<ComplexConfig>::new(999);
 1267|      1|        assert!(registry.read(&fake_handle).is_err());
 1268|       |
 1269|      1|        println!(" read_as_json complex data: {json_result}");
 1270|      1|    }
 1271|       |
 1272|       |    #[test]
 1273|      1|    fn test_read_as_json_serialize_constraint() {
 1274|       |        // This test verifies that the macro correctly adds T: Serialize constraint
 1275|      1|        let registry = ConfigRegistry::new();
 1276|      1|        let config = SimpleConfig { value: 123 };
 1277|      1|        let handle = registry.create(config).unwrap();
 1278|       |
 1279|       |        // SimpleConfig implements Serialize, so this should work
 1280|      1|        let _json_result = registry.read_as_json(&handle);
 1281|       |
 1282|       |        // If we tried to use a non-Serialize type, it would fail at compile time
 1283|       |        // This is automatically verified by the compiler when the macro generates
 1284|       |        // the T: 'static + serde::Serialize constraint
 1285|      1|        println!(" read_as_json Serialize constraint enforced at compile time");
 1286|      1|    }
 1287|       |
 1288|       |    #[test]
 1289|      1|    fn test_read_as_json_arc_dereferencing() {
 1290|      1|        let registry = ConfigRegistry::new();
 1291|      1|        let config = SimpleConfig { value: 999 };
 1292|      1|        let handle = registry.create(config).unwrap();
 1293|       |
 1294|      1|        let json_result = registry.read_as_json(&handle);
 1295|      1|        let result: serde_json::Value = serde_json::from_str(&json_result).unwrap();
 1296|       |
 1297|      1|        assert_eq!(result["success"], true);
 1298|      1|        assert_eq!(result["data"]["value"], 999);
 1299|       |
 1300|       |        // If Arc<T> wasn't properly dereferenced with &*result, 
 1301|       |        // serialization would fail. The fact we get valid JSON proves it works.
 1302|      1|        println!(" read_as_json Arc dereferencing works correctly");
 1303|      1|    }
 1304|       |
 1305|       |    // ===== Missing tests for 100% coverage =====
 1306|       |
 1307|       |    #[test]
 1308|      1|    fn test_disable_success() {
 1309|       |        use crate::config_flags::runtime;
 1310|       |
 1311|      1|        let registry = ConfigRegistry::new()
 1312|      1|            .enable(runtime::STRICT_MODE)
 1313|      1|            .enable(runtime::PARALLEL);
 1314|       |
 1315|       |        // Verify flags are enabled first
 1316|      1|        assert!(registry.runtime_enabled(runtime::STRICT_MODE));
 1317|      1|        assert!(registry.runtime_enabled(runtime::PARALLEL));
 1318|       |
 1319|       |        // Test disable
 1320|      1|        let registry = registry.disable(runtime::STRICT_MODE);
 1321|       |
 1322|       |        // Verify STRICT_MODE is disabled, PARALLEL still enabled
 1323|      1|        assert!(!registry.runtime_enabled(runtime::STRICT_MODE));
 1324|      1|        assert!(registry.runtime_enabled(runtime::PARALLEL));
 1325|       |
 1326|      1|        println!(" Disable success: flag disabled correctly");
 1327|      1|    }
 1328|       |
 1329|       |    #[test]
 1330|      1|    fn test_disable_error_handling() {
 1331|      1|        let registry = ConfigRegistry::new();
 1332|       |
 1333|       |        // Use an invalid flag that should cause a logffi error but continue chain
 1334|      1|        let result = registry.disable(0xFFFFFFFF); // Invalid flag
 1335|       |
 1336|       |        // Should continue chain even with invalid flag
 1337|       |        // The error is logged but chain continues
 1338|       |        
 1339|       |        // Verify registry still works after invalid flag
 1340|      1|        let handle = result.create("test".to_string()).unwrap();
 1341|      1|        let data = result.read(&handle).unwrap();
 1342|      1|        assert_eq!(*data, "test");
 1343|       |
 1344|      1|        println!(" Disable error handling: invalid flag handled gracefully");
 1345|      1|    }
 1346|       |
 1347|       |    #[test]
 1348|      1|    fn test_disable_as_json_success() {
 1349|       |        use crate::config_flags::runtime;
 1350|       |
 1351|      1|        let registry = ConfigRegistry::new()
 1352|      1|            .enable(runtime::STRICT_MODE);
 1353|       |
 1354|      1|        let json_result = registry.disable_as_json(runtime::STRICT_MODE);
 1355|       |
 1356|      1|        let result: serde_json::Value = serde_json::from_str(&json_result).unwrap();
 1357|      1|        assert_eq!(result["success"], true);
 1358|       |        // handle_mode should not include data field
 1359|      1|        assert!(result.get("data").is_none());
 1360|       |
 1361|      1|        println!(" disable_as_json success: {json_result}");
 1362|      1|    }
 1363|       |
 1364|       |    #[test]
 1365|      1|    fn test_disable_as_json_error() {
 1366|      1|        let registry = ConfigRegistry::new();
 1367|      1|        let json_result = registry.disable_as_json(0xFFFFFFFF); // Invalid flag
 1368|       |
 1369|      1|        let result: serde_json::Value = serde_json::from_str(&json_result).unwrap();
 1370|      1|        assert_eq!(result["success"], true); // Should still be true since our disable method continues chain
 1371|       |
 1372|      1|        println!(" disable_as_json with invalid flag: {json_result}");
 1373|      1|    }
 1374|       |
 1375|       |    #[test]
 1376|      1|    fn test_get_runtime_flags() {
 1377|       |        use crate::config_flags::runtime;
 1378|       |
 1379|      1|        let registry = ConfigRegistry::new();
 1380|       |        
 1381|       |        // Initially no flags
 1382|      1|        assert_eq!(registry.get_runtime_flags(), 0);
 1383|       |
 1384|       |        // Enable some flags
 1385|      1|        let registry = registry
 1386|      1|            .enable(runtime::STRICT_MODE)
 1387|      1|            .enable(runtime::PARALLEL);
 1388|       |
 1389|      1|        let flags = registry.get_runtime_flags();
 1390|      1|        assert_ne!(flags, 0);
 1391|      1|        assert_eq!(flags & runtime::STRICT_MODE, runtime::STRICT_MODE);
 1392|      1|        assert_eq!(flags & runtime::PARALLEL, runtime::PARALLEL);
 1393|       |
 1394|       |        // Disable one flag
 1395|      1|        let registry = registry.disable(runtime::STRICT_MODE);
 1396|      1|        let flags = registry.get_runtime_flags();
 1397|      1|        assert_eq!(flags & runtime::STRICT_MODE, 0);
 1398|      1|        assert_eq!(flags & runtime::PARALLEL, runtime::PARALLEL);
 1399|       |
 1400|      1|        println!(" get_runtime_flags: returns correct flag values");
 1401|      1|    }
 1402|       |
 1403|       |    #[test]
 1404|      1|    fn test_update_handle_not_found() {
 1405|      1|        let registry = ConfigRegistry::new();
 1406|      1|        let fake_handle = ConfigHandle::<SimpleConfig>::new(999);
 1407|       |
 1408|      1|        let result = registry.update(&fake_handle, SimpleConfig { value: 42 });
 1409|      1|        assert!(result.is_err());
 1410|      1|        let error_msg = result.unwrap_err();
 1411|      1|        assert!(error_msg.contains("Handle 999 not found for update"));
 1412|       |
 1413|      1|        println!(" Update error handling: handle not found");
 1414|      1|    }
 1415|       |
 1416|       |    #[test]
 1417|      1|    fn test_delete_handle_not_found() {
 1418|      1|        let registry = ConfigRegistry::new();
 1419|      1|        let fake_handle = ConfigHandle::<SimpleConfig>::new(999);
 1420|       |
 1421|      1|        let result = registry.delete(&fake_handle);
 1422|      1|        assert!(result.is_err());
 1423|      1|        let error_msg = result.unwrap_err();
 1424|      1|        assert!(error_msg.contains("Handle 999 not found for delete"));
 1425|       |
 1426|      1|        println!(" Delete error handling: handle not found");
 1427|      1|    }
 1428|       |
 1429|       |    #[test]
 1430|      1|    fn test_delete_wrong_type() {
 1431|      1|        let registry = ConfigRegistry::new();
 1432|      1|        let config = TestConfig {
 1433|      1|            host: "localhost".to_string(),
 1434|      1|            port: 8080,
 1435|      1|            timeout_ms: 5000,
 1436|      1|        };
 1437|       |
 1438|      1|        let handle = registry.create(config).unwrap();
 1439|       |
 1440|       |        // Try to delete as wrong type
 1441|      1|        let wrong_handle = ConfigHandle::<SimpleConfig>::new(handle.id());
 1442|      1|        let result = registry.delete(&wrong_handle);
 1443|       |
 1444|      1|        assert!(result.is_err());
 1445|      1|        let error_msg = result.unwrap_err();
 1446|      1|        assert!(error_msg.contains("Wrong type for delete"));
 1447|      1|        assert!(error_msg.contains("expected"));
 1448|      1|        assert!(error_msg.contains("found"));
 1449|       |
 1450|      1|        println!(" Delete wrong type: error handled correctly");
 1451|      1|    }
 1452|       |
 1453|       |    #[test]
 1454|      1|    fn test_get_arc_data_success_path() {
 1455|      1|        let registry = ConfigRegistry::new();
 1456|      1|        let config = SimpleConfig { value: 123 };
 1457|       |
 1458|      1|        let handle = registry.create(config.clone()).unwrap();
 1459|       |        
 1460|       |        // This tests the success path in get_arc_data (line 65)
 1461|      1|        let data = registry.read(&handle).unwrap();
 1462|      1|        assert_eq!(data.value, 123);
 1463|       |
 1464|       |        // Multiple reads should return same Arc
 1465|      1|        let data2 = registry.read(&handle).unwrap();
 1466|      1|        assert!(Arc::ptr_eq(&data, &data2));
 1467|       |
 1468|      1|        println!(" get_arc_data success path: downcast succeeds");
 1469|      1|    }
 1470|       |
 1471|       |    #[test]
 1472|      1|    fn test_comprehensive_crud_operations() {
 1473|       |        // This test specifically targets uncovered lines in CRUD operations
 1474|      1|        let registry = ConfigRegistry::new();
 1475|       |        
 1476|       |        // Test create operation with complex data to hit all paths
 1477|      1|        let complex_config = TestConfig {
 1478|      1|            host: "localhost".to_string(),
 1479|      1|            port: 8080,
 1480|      1|            timeout_ms: 5000,
 1481|      1|        };
 1482|       |        
 1483|      1|        let handle = registry.create(complex_config.clone()).unwrap();
 1484|       |        
 1485|       |        // Test read operation to hit stats increment and get_arc_data success path (lines 328-329, 332, 65)
 1486|      1|        let data1 = registry.read(&handle).unwrap();
 1487|      1|        let data2 = registry.read(&handle).unwrap();
 1488|      1|        assert_eq!(*data1, complex_config);
 1489|      1|        assert!(Arc::ptr_eq(&data1, &data2)); // Test line 65 success path
 1490|       |        
 1491|       |        // Test update operation to hit all success paths (lines 369, 372-373, 376, 380-383, 386)
 1492|      1|        let updated_config = TestConfig {
 1493|      1|            host: "remote".to_string(),
 1494|      1|            port: 9090,
 1495|      1|            timeout_ms: 10000,
 1496|      1|        };
 1497|      1|        registry.update(&handle, updated_config.clone()).unwrap();
 1498|       |        
 1499|      1|        let updated_data = registry.read(&handle).unwrap();
 1500|      1|        assert_eq!(*updated_data, updated_config);
 1501|       |        
 1502|       |        // Test delete operation to hit all success paths (lines 417, 424, 430-432, 435)
 1503|      1|        let deleted_data = registry.delete(&handle).unwrap();
 1504|      1|        assert_eq!(*deleted_data, updated_config);
 1505|       |        
 1506|       |        // Verify handle no longer exists
 1507|      1|        assert!(!registry.contains_handle(&handle));
 1508|       |        
 1509|       |        // Check statistics were properly updated
 1510|      1|        let stats = registry.stats();
 1511|      1|        assert!(stats.total_creates > 0);
 1512|      1|        assert!(stats.total_reads > 0);
 1513|      1|        assert!(stats.total_updates > 0);
 1514|      1|        assert!(stats.total_deletes > 0);
 1515|       |        
 1516|      1|        println!(" Comprehensive CRUD: all internal paths exercised");
 1517|      1|    }
 1518|       |
 1519|       |    #[test]
 1520|      1|    fn test_multiple_operations_for_coverage() {
 1521|       |        // Additional test to ensure we hit every possible code path
 1522|      1|        let registry = ConfigRegistry::new();
 1523|       |        
 1524|       |        // Create multiple handles to exercise different scenarios
 1525|      1|        let handle1 = registry.create(SimpleConfig { value: 1 }).unwrap();
 1526|      1|        let handle2 = registry.create(SimpleConfig { value: 2 }).unwrap();
 1527|      1|        let handle3 = registry.create(TestConfig {
 1528|      1|            host: "test".to_string(),
 1529|      1|            port: 3000,
 1530|      1|            timeout_ms: 1000,
 1531|      1|        }).unwrap();
 1532|       |        
 1533|       |        // Multiple reads to ensure statistics paths are hit
 1534|      1|        let _data1a = registry.read(&handle1).unwrap();
 1535|      1|        let _data1b = registry.read(&handle1).unwrap();
 1536|      1|        let _data2 = registry.read(&handle2).unwrap();
 1537|      1|        let _data3 = registry.read(&handle3).unwrap();
 1538|       |        
 1539|       |        // Update operations
 1540|      1|        registry.update(&handle1, SimpleConfig { value: 11 }).unwrap();
 1541|      1|        registry.update(&handle2, SimpleConfig { value: 22 }).unwrap();
 1542|       |        
 1543|       |        // More reads after updates
 1544|      1|        let _updated1 = registry.read(&handle1).unwrap();
 1545|      1|        let _updated2 = registry.read(&handle2).unwrap();
 1546|       |        
 1547|       |        // Delete operations
 1548|      1|        let _deleted1 = registry.delete(&handle1).unwrap();
 1549|      1|        let _deleted2 = registry.delete(&handle2).unwrap();
 1550|      1|        let _deleted3 = registry.delete(&handle3).unwrap();
 1551|       |        
 1552|       |        // Final statistics check
 1553|      1|        let stats = registry.stats();
 1554|      1|        assert_eq!(stats.total_creates, 3);
 1555|      1|        assert!(stats.total_reads >= 6);
 1556|      1|        assert_eq!(stats.total_updates, 2);
 1557|      1|        assert_eq!(stats.total_deletes, 3);
 1558|       |        
 1559|      1|        println!(" Multiple operations: comprehensive path coverage");
 1560|      1|    }
 1561|       |
 1562|       |    #[test]
 1563|      1|    fn test_delete_wrong_type_explicit_logging() {
 1564|       |        // This test specifically targets line 424 - the error logging in delete wrong type path
 1565|      1|        let registry = ConfigRegistry::new();
 1566|       |        
 1567|       |        // Create a TestConfig entry
 1568|      1|        let config = TestConfig {
 1569|      1|            host: "test".to_string(),
 1570|      1|            port: 1234,
 1571|      1|            timeout_ms: 2000,
 1572|      1|        };
 1573|      1|        let handle = registry.create(config).unwrap();
 1574|       |        
 1575|       |        // Now try to delete it as SimpleConfig (wrong type)
 1576|       |        // This should trigger both the error message formatting AND the error logging
 1577|      1|        let wrong_handle = ConfigHandle::<SimpleConfig>::new(handle.id());
 1578|      1|        let result = registry.delete(&wrong_handle);
 1579|       |        
 1580|       |        // Verify the error path was taken
 1581|      1|        assert!(result.is_err());
 1582|      1|        let error_msg = result.unwrap_err();
 1583|       |        
 1584|       |        // This should ensure both lines 423 AND 424 are executed
 1585|      1|        assert!(error_msg.contains("Wrong type for delete"));
 1586|      1|        assert!(error_msg.contains("SimpleConfig"));
 1587|      1|        assert!(error_msg.contains("TestConfig"));
 1588|       |        
 1589|       |        // Force the error to be processed to ensure logging actually happens
 1590|      1|        eprintln!("Expected error occurred: {}", error_msg);
 1591|       |        
 1592|      1|        println!(" Delete wrong type explicit logging: line 424 covered");
 1593|      1|    }
 1594|       |
 1595|       |    #[test]
 1596|      1|    fn test_delete_testconfig_wrong_type_closure() {
 1597|       |        // This test specifically targets the missing closure for TestConfig delete wrong type
 1598|      1|        let registry = ConfigRegistry::new();
 1599|       |        
 1600|       |        // Create a SimpleConfig entry  
 1601|      1|        let simple_config = SimpleConfig { value: 42 };
 1602|      1|        let handle = registry.create(simple_config).unwrap();
 1603|       |        
 1604|       |        // Try to delete it as TestConfig (wrong type) - this exercises the missing closure
 1605|      1|        let wrong_handle = ConfigHandle::<TestConfig>::new(handle.id());
 1606|      1|        let result = registry.delete(&wrong_handle);
 1607|       |        
 1608|       |        // Verify the error path was taken
 1609|      1|        assert!(result.is_err());
 1610|      1|        let error_msg = result.unwrap_err();
 1611|      1|        assert!(error_msg.contains("Wrong type for delete"));
 1612|      1|        assert!(error_msg.contains("TestConfig"));
 1613|      1|        assert!(error_msg.contains("SimpleConfig"));
 1614|       |        
 1615|      1|        println!(" Delete TestConfig wrong type closure: missing function coverage achieved");
 1616|      1|    }
 1617|       |
 1618|       |}

/home/nsm/code/deepbrain/superconfig/crates/superconfig/src/core/stats.rs:
    1|       |//! Statistics tracking for the `SuperConfig` V2 registry system
    2|       |
    3|       |/// Statistics about the registry state
    4|       |#[derive(Debug, Clone, Default)]
    5|       |pub struct RegistryStats {
    6|       |    /// Total number of active handles
    7|       |    pub total_handles: u64,
    8|       |    /// Total number of create operations
    9|       |    pub total_creates: u64,
   10|       |    /// Total number of read operations
   11|       |    pub total_reads: u64,
   12|       |    /// Total number of update operations
   13|       |    pub total_updates: u64,
   14|       |    /// Total number of delete operations
   15|       |    pub total_deletes: u64,
   16|       |    /// Approximate memory usage in bytes
   17|       |    pub memory_usage_bytes: u64,
   18|       |}
   19|       |
   20|       |impl RegistryStats {
   21|       |    /// Create new empty statistics
   22|       |    #[must_use]
   23|      5|    pub fn new() -> Self {
   24|      5|        Self::default()
   25|      5|    }
   26|       |
   27|       |    /// Reset all statistics to zero
   28|      2|    pub fn reset(&mut self) {
   29|      2|        *self = Self::default();
   30|      2|    }
   31|       |
   32|       |    /// Add memory usage
   33|  1.53k|    pub const fn add_memory(&mut self, bytes: u64) {
   34|  1.53k|        self.memory_usage_bytes = self.memory_usage_bytes.saturating_add(bytes);
   35|  1.53k|    }
   36|       |
   37|       |    /// Remove memory usage
   38|    855|    pub const fn remove_memory(&mut self, bytes: u64) {
   39|    855|        self.memory_usage_bytes = self.memory_usage_bytes.saturating_sub(bytes);
   40|    855|    }
   41|       |
   42|       |    /// Increment create counter
   43|  1.03k|    pub const fn increment_creates(&mut self) {
   44|  1.03k|        self.total_creates = self.total_creates.saturating_add(1);
   45|  1.03k|        self.total_handles = self.total_handles.saturating_add(1);
   46|  1.03k|    }
   47|       |
   48|       |    /// Increment read counter
   49|  1.02k|    pub const fn increment_reads(&mut self) {
   50|  1.02k|        self.total_reads = self.total_reads.saturating_add(1);
   51|  1.02k|    }
   52|       |
   53|       |    /// Increment update counter
   54|    506|    pub const fn increment_updates(&mut self) {
   55|    506|        self.total_updates = self.total_updates.saturating_add(1);
   56|    506|    }
   57|       |
   58|       |    /// Increment delete counter
   59|    349|    pub const fn increment_deletes(&mut self) {
   60|    349|        self.total_deletes = self.total_deletes.saturating_add(1);
   61|    349|        self.total_handles = self.total_handles.saturating_sub(1);
   62|    349|    }
   63|       |}
   64|       |
   65|       |#[cfg(test)]
   66|       |mod tests {
   67|       |    use super::*;
   68|       |
   69|       |    #[test]
   70|      1|    fn test_stats_new_and_default() {
   71|      1|        let stats1 = RegistryStats::new();
   72|      1|        let stats2 = RegistryStats::default();
   73|       |
   74|      1|        assert_eq!(stats1.total_handles, 0);
   75|      1|        assert_eq!(stats1.total_creates, 0);
   76|      1|        assert_eq!(stats1.total_reads, 0);
   77|      1|        assert_eq!(stats1.total_updates, 0);
   78|      1|        assert_eq!(stats1.total_deletes, 0);
   79|      1|        assert_eq!(stats1.memory_usage_bytes, 0);
   80|       |
   81|      1|        assert_eq!(stats1.total_handles, stats2.total_handles);
   82|      1|        assert_eq!(stats1.total_creates, stats2.total_creates);
   83|      1|    }
   84|       |
   85|       |    #[test]
   86|      1|    fn test_stats_operations() {
   87|      1|        let mut stats = RegistryStats::new();
   88|       |
   89|       |        // Test create operation
   90|      1|        stats.increment_creates();
   91|      1|        assert_eq!(stats.total_creates, 1);
   92|      1|        assert_eq!(stats.total_handles, 1);
   93|       |
   94|       |        // Test read operation
   95|      1|        stats.increment_reads();
   96|      1|        assert_eq!(stats.total_reads, 1);
   97|      1|        assert_eq!(stats.total_handles, 1); // Should not change
   98|       |
   99|       |        // Test update operation
  100|      1|        stats.increment_updates();
  101|      1|        assert_eq!(stats.total_updates, 1);
  102|      1|        assert_eq!(stats.total_handles, 1); // Should not change
  103|       |
  104|       |        // Test delete operation
  105|      1|        stats.increment_deletes();
  106|      1|        assert_eq!(stats.total_deletes, 1);
  107|      1|        assert_eq!(stats.total_handles, 0); // Should decrease
  108|      1|    }
  109|       |
  110|       |    #[test]
  111|      1|    fn test_memory_tracking() {
  112|      1|        let mut stats = RegistryStats::new();
  113|       |
  114|      1|        stats.add_memory(100);
  115|      1|        assert_eq!(stats.memory_usage_bytes, 100);
  116|       |
  117|      1|        stats.add_memory(50);
  118|      1|        assert_eq!(stats.memory_usage_bytes, 150);
  119|       |
  120|      1|        stats.remove_memory(30);
  121|      1|        assert_eq!(stats.memory_usage_bytes, 120);
  122|       |
  123|       |        // Test underflow protection
  124|      1|        stats.remove_memory(200);
  125|      1|        assert_eq!(stats.memory_usage_bytes, 0);
  126|      1|    }
  127|       |
  128|       |    #[test]
  129|      1|    fn test_overflow_protection() {
  130|      1|        let mut stats = RegistryStats::new();
  131|      1|        stats.total_creates = u64::MAX;
  132|      1|        stats.total_handles = u64::MAX;
  133|      1|        stats.memory_usage_bytes = u64::MAX;
  134|       |
  135|       |        // These should not panic due to saturating operations
  136|      1|        stats.increment_creates();
  137|      1|        stats.add_memory(100);
  138|       |
  139|      1|        assert_eq!(stats.total_creates, u64::MAX);
  140|      1|        assert_eq!(stats.total_handles, u64::MAX);
  141|      1|        assert_eq!(stats.memory_usage_bytes, u64::MAX);
  142|      1|    }
  143|       |
  144|       |    #[test]
  145|      1|    fn test_reset() {
  146|      1|        let mut stats = RegistryStats::new();
  147|       |
  148|       |        // Set some values
  149|      1|        stats.increment_creates();
  150|      1|        stats.increment_reads();
  151|      1|        stats.add_memory(1000);
  152|       |
  153|      1|        assert_ne!(stats.total_creates, 0);
  154|      1|        assert_ne!(stats.total_reads, 0);
  155|      1|        assert_ne!(stats.memory_usage_bytes, 0);
  156|       |
  157|       |        // Reset
  158|      1|        stats.reset();
  159|       |
  160|      1|        assert_eq!(stats.total_creates, 0);
  161|      1|        assert_eq!(stats.total_reads, 0);
  162|      1|        assert_eq!(stats.memory_usage_bytes, 0);
  163|      1|    }
  164|       |}
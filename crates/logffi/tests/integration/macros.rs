use logffi::{debug, define_errors, error, info, trace, warn};

#[test]
fn test_basic_macro_functionality() {
    // Test that our generated macros compile and work
    // These should not panic and should execute without errors
    error!("Test error message");
    warn!("Test warning message");
    info!("Test info message");
    debug!("Test debug message");
    trace!("Test trace message");
}

#[test]
fn test_macros_with_target() {
    // Test that macros work with explicit targets
    error!(target: "test_target", "Error with target");
    warn!(target: "test_target", "Warning with target");
    info!(target: "test_target", "Info with target");
    debug!(target: "test_target", "Debug with target");
    trace!(target: "test_target", "Trace with target");
}

#[test]
fn test_macros_with_formatting() {
    // Test that macros work with format arguments
    let value = 42;
    let name = "test";

    error!("Error value: {}", value);
    warn!("Warning with multiple: {} {}", value, name);
    info!("Info: {:?}", vec![1, 2, 3]);
    debug!("Debug: {value}", value = "test");
    trace!("Trace with multiple args: {} {} {}", 1, 2, 3);
}

#[test]
fn test_macros_with_target_and_formatting() {
    // Test combining target and formatting
    let id = 123;
    error!(target: "app::db", "Database error for user {}", id);
    warn!(target: "app::auth", "Login attempt failed for user: {}", id);
    info!(target: "app::server", "Server started on port: {}", 8080);
}

#[test]
fn test_all_log_levels_generated() {
    // Verify all 5 log levels were generated by meta-rust for_each! macro
    // This confirms our macro generation is working

    // Should not cause compilation errors - proves macros exist
    error!("macro test");
    warn!("macro test");
    info!("macro test");
    debug!("macro test");
    trace!("macro test");
}

#[test]
fn test_define_errors_basic() {
    // Test define_errors! macro basic functionality
    define_errors! {
        pub enum TestError {
            #[error("Test error occurred", level = error, target = "test::macro")]
            TestFailed,

            #[error("Missing value", level = warn)]
            MissingValue,
        }
    }

    // Test that we can create errors
    let error1 = TestError::TestFailed;
    let error2 = TestError::MissingValue;

    // Test Display trait
    assert_eq!(error1.to_string(), "Test error occurred");
    assert_eq!(error2.to_string(), "Missing value");

    // Test code() method
    assert_eq!(error1.code(), "TestFailed");
    assert_eq!(error2.code(), "MissingValue");

    // Test kind() method
    assert_eq!(error1.kind(), "TestFailed");
    assert_eq!(error2.kind(), "MissingValue");

    // Test log() method - should not panic
    error1.log();
    error2.log();
}

#[test]
fn test_define_errors_with_fields() {
    // Test errors with fields
    define_errors! {
        #[derive(Clone)]
        pub enum FieldError {
            #[error("Key '{key}' not found", level = warn, target = "test::fields")]
            KeyNotFound {
                key: String,
            },

            #[error("Operation '{op}' failed: {reason}", level = error, code = "OP_001")]
            OperationFailed {
                op: String,
                reason: String,
            },
        }
    }

    let error1 = FieldError::KeyNotFound {
        key: "database.host".to_string(),
    };

    let error2 = FieldError::OperationFailed {
        op: "save".to_string(),
        reason: "disk full".to_string(),
    };

    // Test error messages include field values
    assert!(error1.to_string().contains("database.host"));
    assert!(error2.to_string().contains("save"));
    assert!(error2.to_string().contains("disk full"));

    // Test custom error code
    assert_eq!(error2.code(), "OP_001");

    // Test logging
    error1.log();
    error2.log();
}

#[test]
fn test_define_errors_all_log_levels() {
    // Test all log levels work
    define_errors! {
        pub enum LogLevelTest {
            #[error("Error level", level = error)]
            ErrorLevel,

            #[error("Warn level", level = warn)]
            WarnLevel,

            #[error("Info level", level = info)]
            InfoLevel,

            #[error("Debug level", level = debug)]
            DebugLevel,

            #[error("Trace level", level = trace)]
            TraceLevel,
        }
    }

    // Test all levels - should not panic
    LogLevelTest::ErrorLevel.log();
    LogLevelTest::WarnLevel.log();
    LogLevelTest::InfoLevel.log();
    LogLevelTest::DebugLevel.log();
    LogLevelTest::TraceLevel.log();
}

#[test]
fn test_constructor_methods() {
    // Test the new_variant_name constructor methods
    define_errors! {
        pub enum ConstructorTest {
            #[error("Simple error", level = error)]
            SimpleError,

            #[error("Error with field: {value}", level = warn, target = "test::constructor")]
            WithField {
                value: String,
            },

            #[error("Multiple fields: {name} = {count}", level = info, code = "MULTI_001")]
            MultipleFields {
                name: String,
                count: u32,
            },
        }
    }

    // Test simple constructor (no fields)
    let error1 = ConstructorTest::new_simple_error();
    assert_eq!(error1.to_string(), "Simple error");
    assert_eq!(error1.code(), "SimpleError");

    // Test constructor with single field
    let error2 = ConstructorTest::new_with_field("test_value".to_string());
    assert_eq!(error2.to_string(), "Error with field: test_value");
    assert_eq!(error2.code(), "WithField");

    // Test constructor with multiple fields
    let error3 = ConstructorTest::new_multiple_fields("counter".to_string(), 42);
    assert_eq!(error3.to_string(), "Multiple fields: counter = 42");
    assert_eq!(error3.code(), "MULTI_001");
}

#[test]
fn test_source_error_chaining() {
    use std::error::Error;
    use std::io;

    // Test errors with source chaining using thiserror's #[source] attribute
    define_errors! {
        pub enum SourceTest {
            #[error("IO operation failed for {path}", level = error)]
            IoError {
                path: String,
                #[source]
                source: io::Error,
            },

            #[error("Parse error in {file}", level = error, target = "test::parse")]
            ParseError {
                file: String,
                #[source]
                source: serde_json::Error,
            },

            #[error("No source error", level = warn)]
            NoSource {
                message: String,
            },
        }
    }

    // Test IO error with source
    let io_err = io::Error::new(io::ErrorKind::NotFound, "file not found");
    let error1 = SourceTest::IoError {
        path: "/tmp/test.txt".to_string(),
        source: io_err,
    };

    // Check error message
    assert_eq!(error1.to_string(), "IO operation failed for /tmp/test.txt");

    // Check source chain
    assert!(error1.source().is_some());
    let source = error1.source().unwrap();
    assert_eq!(source.to_string(), "file not found");

    // Test parse error with source
    let json_err = serde_json::from_str::<serde_json::Value>("invalid").unwrap_err();
    let error2 = SourceTest::ParseError {
        file: "config.json".to_string(),
        source: json_err,
    };

    assert_eq!(error2.to_string(), "Parse error in config.json");
    assert!(error2.source().is_some());

    // Test error without source
    let error3 = SourceTest::NoSource {
        message: "test message".to_string(),
    };

    assert_eq!(error3.to_string(), "No source error");
    assert!(error3.source().is_none());

    // Test that errors can be logged
    error1.log();
    error2.log();
    error3.log();
}

// Enhanced define_errors! macro with structured tracing integration
// This module ONLY contains the define_errors! macro - all logging macros are in tracing.rs

/// Enhanced `define_errors!` macro with structured tracing integration
/// 
/// Supports both thiserror-style and simplified LogFFI-style syntax:
/// 
/// ```rust
/// use logffi::define_errors;
/// 
/// // New simplified LogFFI syntax (recommended) - unit variants with empty braces
/// define_errors! {
///     SimpleError {
///         NotFound {} : "Resource not found" [level = error],
///         InvalidInput {} : "Invalid input provided" [level = warn]
///     }
/// }
/// 
/// // LogFFI syntax - struct variants (with braces and fields)
/// define_errors! {
///     PaymentError {
///         InsufficientFunds { amount: f64, available: f64 } : "Need ${amount}, have ${available}" [level = error],
///         NetworkError { source: std::io::Error } : "Network error occurred"
///     }
/// }
/// 
/// // Multiple error types in single macro call
/// define_errors! {
///     ApiError {
///         BadRequest {} : "Invalid request" [level = warn],
///         Unauthorized {} : "Access denied" [level = error]
///     }
///     
///     StorageError {
///         ConnectionFailed { host: String } : "Failed to connect to {host}" [level = error],
///         QueryTimeout {} : "Query timed out" [level = warn]
///     }
/// }
/// 
/// // Traditional thiserror syntax (still supported)
/// define_errors! {
///     pub enum DatabaseError {
///         #[error("Connection failed", level = error)]
///         ConnectionFailed,
///     }
/// }
/// ```
#[macro_export]
macro_rules! define_errors {
    // Traditional thiserror syntax (must come first to avoid conflicts)
    (
        $(#[$enum_meta:meta])*
        $vis:vis enum $name:ident {
            $(
                #[error($msg:literal $(, level = $level:ident)? $(, target = $target:literal)? $(, source)?)]
                $variant:ident $({
                    $(
                        $(#[$field_meta:meta])*
                        $field_name:ident: $field_type:ty
                    ),* $(,)?
                })?,
            )*
        }
    ) => {
        // Generate thiserror Error enum with source chain support
        #[derive(thiserror::Error, Debug)]
        $(#[$enum_meta])*
        $vis enum $name {
            $(
                #[error($msg)]
                $variant $({
                    $(
                        $(#[$field_meta])*
                        $field_name: $field_type
                    ),*
                })?,
            )*
        }

        impl $name {
            /// Automatically log this error with structured tracing (preserves source chain)
            pub fn log(&self) {
                match self {
                    $(
                        Self::$variant { .. } => {
                            let code = self.code();
                            let message = self.to_string();
                            
                            // Use traditional thiserror attribute parsing
                            define_errors!(@log_thiserror $($level)? $($target)? ; code, message);
                        },
                    )*
                }
            }
            
            /// Get error code for API stability
            pub fn code(&self) -> &'static str {
                match self {
                    $(
                        Self::$variant { .. } => stringify!($variant),
                    )*
                }
            }
        }
    };

    // LogFFI syntax - multiple error types in one macro call (must come before single type)
    (
        $first_name:ident {
            $($first_tokens:tt)*
        }
        $($rest_name:ident {
            $($rest_tokens:tt)*
        })+
    ) => {
        // Process the first error type
        define_errors! {
            $first_name {
                $($first_tokens)*
            }
        }
        
        // Process the remaining error types
        define_errors! {
            $($rest_name {
                $($rest_tokens)*
            })+
        }
    };

    // LogFFI syntax - single error type (mixed variants with mandatory braces)
    (
        $name:ident {
            $($tokens:tt)*
        }
    ) => {
        // Collect all the variant information first
        define_errors!(@collect 
            name: $name,
            variants: [],
            tokens: [$($tokens)*]
        );
    };
    
    // Collect variant - handle both empty braces and braces with fields
    (@collect
        name: $name:ident,
        variants: [$($variants:tt)*],
        tokens: [
            $variant:ident { $($field_name:ident : $field_type:ty),* $(,)? } : $msg:literal $([$($attr:tt)*])? 
            $(, $($rest:tt)*)?
        ]
    ) => {
        define_errors!(@collect
            name: $name,
            variants: [$($variants)*
                ($variant, $msg, ($($field_name : $field_type),*), $([$($attr)*])?)
            ],
            tokens: [$($($rest)*)?]
        );
    };
    
    // Done collecting - now generate
    (@collect
        name: $name:ident,
        variants: [$($variants:tt)*],
        tokens: []
    ) => {
        define_errors!(@build $name; $($variants)*);
    };
    
    // Build the final enum - handle empty and non-empty field cases separately
    (@build $name:ident; $(($variant:ident, $msg:literal, (), $([$($attr:tt)*])?))*) => {
        // All unit variants (no fields)
        #[derive(thiserror::Error, Debug)]
        pub enum $name {
            $(
                #[error($msg)]
                $variant,
            )*
        }

        impl $name {
            pub fn log(&self) {
                match self {
                    $(
                        Self::$variant => {
                            let code = self.code();
                            let message = self.to_string();
                            define_errors!(@log_simple $([$($attr)*])? ; code, message);
                        },
                    )*
                }
            }
            
            pub fn code(&self) -> &'static str {
                match self {
                    $(
                        Self::$variant => stringify!($variant),
                    )*
                }
            }
        }
    };

    (@build $name:ident; $(($variant:ident, $msg:literal, ($($field_name:ident : $field_type:ty),+), $([$($attr:tt)*])?))*) => {
        // All struct variants (with fields)
        #[derive(thiserror::Error, Debug)]
        pub enum $name {
            $(
                #[error($msg)]
                $variant {
                    $($field_name : $field_type),+
                },
            )*
        }

        impl $name {
            pub fn log(&self) {
                match self {
                    $(
                        Self::$variant { .. } => {
                            let code = self.code();
                            let message = self.to_string();
                            define_errors!(@log_simple $([$($attr)*])? ; code, message);
                        },
                    )*
                }
            }
            
            pub fn code(&self) -> &'static str {
                match self {
                    $(
                        Self::$variant { .. } => stringify!($variant),
                    )*
                }
            }
        }
    };

    // Mixed case - this is the tricky one - we need a different approach
    (@build $name:ident; $(($variant:ident, $msg:literal, ($($field_name:ident : $field_type:ty),*), $([$($attr:tt)*])?))*) => {
        // For truly mixed variants, we need to pre-process to separate unit from struct
        define_errors!(@separate_mixed $name; 
            unit_variants: [];
            struct_variants: [];
            remaining: [$(($variant, $msg, ($($field_name : $field_type),*), $([$($attr)*])?))*]
        );
    };

    // Separate mixed variants into unit and struct categories
    (@separate_mixed $name:ident;
        unit_variants: [$($unit_processed:tt)*];
        struct_variants: [$($struct_processed:tt)*];
        remaining: [($variant:ident, $msg:literal, (), $([$($attr:tt)*])?) $($rest:tt)*]
    ) => {
        // This is a unit variant
        define_errors!(@separate_mixed $name;
            unit_variants: [$($unit_processed)* ($variant, $msg, $([$($attr)*])?)];
            struct_variants: [$($struct_processed)*];
            remaining: [$($rest)*]
        );
    };

    (@separate_mixed $name:ident;
        unit_variants: [$($unit_processed:tt)*];
        struct_variants: [$($struct_processed:tt)*];
        remaining: [($variant:ident, $msg:literal, ($($field_name:ident : $field_type:ty),+), $([$($attr:tt)*])?) $($rest:tt)*]
    ) => {
        // This is a struct variant
        define_errors!(@separate_mixed $name;
            unit_variants: [$($unit_processed)*];
            struct_variants: [$($struct_processed)* ($variant, $msg, ($($field_name : $field_type),+), $([$($attr)*])?)];
            remaining: [$($rest)*]
        );
    };

    // Generate the mixed enum once separation is complete
    (@separate_mixed $name:ident;
        unit_variants: [$(($unit_variant:ident, $unit_msg:literal, $([$($unit_attr:tt)*])?))*];
        struct_variants: [$(($struct_variant:ident, $struct_msg:literal, ($($struct_field_name:ident : $struct_field_type:ty),+), $([$($struct_attr:tt)*])?))*];
        remaining: []
    ) => {
        #[derive(thiserror::Error, Debug)]
        pub enum $name {
            $(
                #[error($unit_msg)]
                $unit_variant,
            )*
            $(
                #[error($struct_msg)]
                $struct_variant {
                    $($struct_field_name : $struct_field_type),+
                },
            )*
        }

        impl $name {
            pub fn log(&self) {
                match self {
                    $(
                        Self::$unit_variant => {
                            let code = self.code();
                            let message = self.to_string();
                            define_errors!(@log_simple $([$($unit_attr)*])? ; code, message);
                        },
                    )*
                    $(
                        Self::$struct_variant { .. } => {
                            let code = self.code();
                            let message = self.to_string();
                            define_errors!(@log_simple $([$($struct_attr)*])? ; code, message);
                        },
                    )*
                }
            }
            
            pub fn code(&self) -> &'static str {
                match self {
                    $(
                        Self::$unit_variant => stringify!($unit_variant),
                    )*
                    $(
                        Self::$struct_variant { .. } => stringify!($struct_variant),
                    )*
                }
            }
        }
    };

    // Build mixed enum with both unit and struct variants
    (@build_mixed $name:ident; $((unit, $unit_variant:ident, $unit_msg:literal, $([$($unit_attr:tt)*])?))*) => {
        // All unit variants
        #[derive(thiserror::Error, Debug)]
        pub enum $name {
            $(
                #[error($unit_msg)]
                $unit_variant,
            )*
        }

        impl $name {
            pub fn log(&self) {
                match self {
                    $(
                        Self::$unit_variant => {
                            let code = self.code();
                            let message = self.to_string();
                            define_errors!(@log_simple $([$($unit_attr)*])? ; code, message);
                        },
                    )*
                }
            }
            
            pub fn code(&self) -> &'static str {
                match self {
                    $(
                        Self::$unit_variant => stringify!($unit_variant),
                    )*
                }
            }
        }
    };

    // Build mixed enum - all struct variants
    (@build_mixed $name:ident; $((struct, $struct_variant:ident, $struct_msg:literal, [$($field_name:ident : $field_type:ty),+], $([$($struct_attr:tt)*])?))*) => {
        define_errors!(@generate_struct_enum $name; $(($struct_variant, $struct_msg, [$($field_name : $field_type),+], $([$($struct_attr)*])?))*);
    };

    // Generate struct-only enum
    (@generate_struct_enum $name:ident; $(($variant:ident, $msg:literal, [$($field_name:ident : $field_type:ty),+], $([$($attr:tt)*])?))*) => {
        #[derive(thiserror::Error, Debug)]
        pub enum $name {
            $(
                #[error($msg)]
                $variant {
                    $($field_name : $field_type),+
                },
            )*
        }

        impl $name {
            pub fn log(&self) {
                match self {
                    $(
                        Self::$variant { .. } => {
                            let code = self.code();
                            let message = self.to_string();
                            define_errors!(@log_simple $([$($attr)*])? ; code, message);
                        },
                    )*
                }
            }
            
            pub fn code(&self) -> &'static str {
                match self {
                    $(
                        Self::$variant { .. } => stringify!($variant),
                    )*
                }
            }
        }
    };

    // Build truly mixed enum - use thiserror-style optional struct pattern
    (@build_mixed $name:ident; $(($vtype:tt, $variant:ident, $msg:literal, $($vrest:tt)*))*) => {
        define_errors!(@generate_mixed_enum $name; $(($variant, $msg, $vtype, $($vrest)*))*);
    };

    // Generate mixed enum using thiserror-style optional syntax
    (@generate_mixed_enum $name:ident; $(($variant:ident, $msg:literal, unit, $([$($unit_attr:tt)*])?))*) => {
        // All unit variants
        #[derive(thiserror::Error, Debug)]
        pub enum $name {
            $(
                #[error($msg)]
                $variant,
            )*
        }

        impl $name {
            pub fn log(&self) {
                match self {
                    $(
                        Self::$variant => {
                            let code = self.code();
                            let message = self.to_string();
                            define_errors!(@log_simple $([$($unit_attr)*])? ; code, message);
                        },
                    )*
                }
            }
            
            pub fn code(&self) -> &'static str {
                match self {
                    $(
                        Self::$variant => stringify!($variant),
                    )*
                }
            }
        }
    };

    (@generate_mixed_enum $name:ident; $(($variant:ident, $msg:literal, struct, [$($field_name:ident : $field_type:ty),+], $([$($struct_attr:tt)*])?))*) => {
        // All struct variants
        #[derive(thiserror::Error, Debug)]
        pub enum $name {
            $(
                #[error($msg)]
                $variant {
                    $($field_name : $field_type),+
                },
            )*
        }

        impl $name {
            pub fn log(&self) {
                match self {
                    $(
                        Self::$variant { .. } => {
                            let code = self.code();
                            let message = self.to_string();
                            define_errors!(@log_simple $([$($struct_attr)*])? ; code, message);
                        },
                    )*
                }
            }
            
            pub fn code(&self) -> &'static str {
                match self {
                    $(
                        Self::$variant { .. } => stringify!($variant),
                    )*
                }
            }
        }
    };

    // The key insight: truly mixed enum using thiserror-style optional struct syntax
    (@generate_mixed_enum $name:ident; $(($variant:ident, $msg:literal, $vtype:tt, $($vrest:tt)*))*) => {
        #[derive(thiserror::Error, Debug)]
        pub enum $name {
            $(
                define_errors!(@mixed_variant_direct $variant, $msg, $vtype, $($vrest)*)
            )*
        }

        impl $name {
            pub fn log(&self) {
                match self {
                    $(
                        Self::$variant { .. } => {
                            let code = self.code();
                            let message = self.to_string();
                            define_errors!(@mixed_log_attr $vtype, $($vrest)*);
                        },
                    )*
                }
            }
            
            pub fn code(&self) -> &'static str {
                match self {
                    $(
                        Self::$variant { .. } => stringify!($variant),
                    )*
                }
            }
        }
    };

    // Generate variant directly - unit
    (@mixed_variant_direct $variant:ident, $msg:literal, unit, $([$($attr:tt)*])?) => {
        #[error($msg)]
        $variant,
    };

    // Generate variant directly - struct  
    (@mixed_variant_direct $variant:ident, $msg:literal, struct, [$($field_name:ident : $field_type:ty),+], $([$($attr:tt)*])?) => {
        #[error($msg)]
        $variant {
            $($field_name : $field_type),+
        },
    };

    // Mixed log attribute handling
    (@mixed_log_attr unit, $([$($attr:tt)*])?) => {
        define_errors!(@log_simple $([$($attr)*])? ; code, message);
    };

    (@mixed_log_attr struct, [$($field_name:ident : $field_type:ty),+], $([$($attr:tt)*])?) => {
        define_errors!(@log_simple $([$($attr)*])? ; code, message);
    };
    
    // Make a unit variant
    (@make_variant unit, $variant:ident, $msg:literal, $([$($attr:tt)*])?) => {
        #[error($msg)]
        $variant,
    };
    
    // Make a struct variant
    (@make_variant struct, $variant:ident, $msg:literal, [$($field_name:ident : $field_type:ty),+], $([$($attr:tt)*])?) => {
        #[error($msg)]
        $variant {
            $($field_name : $field_type),+
        },
    };
    
    // Make log arm for unit variant
    (@make_log_arm unit, $variant:ident, $([$($attr:tt)*])?) => {
        Self::$variant => {
            let code = self.code();
            let message = self.to_string();
            define_errors!(@log_simple $([$($attr)*])? ; code, message);
        },
    };
    
    // Make log arm for struct variant  
    (@make_log_arm struct, $variant:ident, [$($field_name:ident : $field_type:ty),+], $([$($attr:tt)*])?) => {
        Self::$variant { .. } => {
            let code = self.code();
            let message = self.to_string();
            define_errors!(@log_simple $([$($attr)*])? ; code, message);
        },
    };
    
    // Make code arm for unit variant
    (@make_code_arm unit, $variant:ident, $($rest:tt)*) => {
        Self::$variant => stringify!($variant),
    };
    
    // Make code arm for struct variant
    (@make_code_arm struct, $variant:ident, $($rest:tt)*) => {
        Self::$variant { .. } => stringify!($variant),
    };

    // NOTE: The old unit-only and struct-only patterns are now handled by the mixed pattern above
    // which supports both unit and struct variants in the same enum

    // Helper: Build enum from parsed variants - unit variants only
    (@build_enum $name:ident; $($variant:ident [] : $msg:literal $([$($attr:tt)*])?);*) => {
        #[derive(thiserror::Error, Debug)]
        pub enum $name {
            $(
                #[error($msg)]
                $variant,
            )*
        }

        impl $name {
            pub fn log(&self) {
                match self {
                    $(
                        Self::$variant => {
                            let code = self.code();
                            let message = self.to_string();
                            define_errors!(@log_simple $([$($attr)*])? ; code, message);
                        },
                    )*
                }
            }
            
            pub fn code(&self) -> &'static str {
                match self {
                    $(
                        Self::$variant => stringify!($variant),
                    )*
                }
            }
        }
    };
    
    // Helper: Build enum from parsed variants - struct variants
    (@build_enum $name:ident; $($variant:ident [{ $($field_name:ident: $field_type:ty),* }] : $msg:literal $([$($attr:tt)*])?);*) => {
        #[derive(thiserror::Error, Debug)]
        pub enum $name {
            $(
                #[error($msg)]
                $variant {
                    $(define_errors!(@add_source_attr $field_name: $field_type)),*
                },
            )*
        }

        impl $name {
            pub fn log(&self) {
                match self {
                    $(
                        Self::$variant { .. } => {
                            let code = self.code();
                            let message = self.to_string();
                            define_errors!(@log_simple $([$($attr)*])? ; code, message);
                        },
                    )*
                }
            }
            
            pub fn code(&self) -> &'static str {
                match self {
                    $(
                        Self::$variant { .. } => stringify!($variant),
                    )*
                }
            }
        }
    };

    // Helper: Make variant (unit or struct)
    (@make_variant $name:ident) => {
        $name
    };
    (@make_variant $name:ident { $($field_name:ident: $field_type:ty),* }) => {
        $name {
            $(define_errors!(@add_source_attr $field_name: $field_type)),*
        }
    };

    // Helper: Make match arm (unit or struct)
    (@make_match_arm $name:ident) => {
        Self::$name
    };
    (@make_match_arm $name:ident { $($field_name:ident: $field_type:ty),* }) => {
        Self::$name { .. }
    };

    // Helper: Simple logging with attributes  
    (@log_simple [$($attr:tt)*] ; $code:expr, $message:expr) => {
        define_errors!(@log_with_attrs $($attr)* ; $code, $message);
    };
    
    (@log_simple ; $code:expr, $message:expr) => {
        $crate::error!(target: module_path!(), "[{}] {}", $code, $message);
    };

    // Helper: Generate variant type (unit or struct)
    (@variant_type $name:ident) => {
        $name
    };
    (@variant_type $name:ident ( )) => {
        $name
    };
    (@variant_type $name:ident ( $($field_name:ident: $field_type:ty),+ )) => {
        $name {
            $(define_errors!(@add_source_attr $field_name: $field_type)),+
        }
    };

    // Helper: Generate match arm pattern
    (@match_arm $name:ident) => {
        Self::$name
    };
    (@match_arm $name:ident ( )) => {
        Self::$name
    };
    (@match_arm $name:ident ( $($field_name:ident),+ )) => {
        Self::$name { .. }
    };

    // Helper: Generate enum with mixed unit and struct variants
    (@generate_mixed_enum $name:ident; $( ($variant:ident; $msg:literal; ($($field_name:ident: $field_type:ty),*); $([$($attr:tt)*])?) ),*) => {
        #[derive(thiserror::Error, Debug)]
        pub enum $name {
            $(
                #[error($msg)]
                define_errors!(@mixed_variant $variant($($field_name: $field_type),*)),
            )*
        }

        impl $name {
            pub fn log(&self) {
                match self {
                    $(
                        define_errors!(@mixed_match_pattern $variant($($field_name),*)) => {
                            let code = self.code();
                            let message = self.to_string();
                            define_errors!(@log_simple $([$($attr)*])? ; code, message);
                        },
                    )*
                }
            }
            
            pub fn code(&self) -> &'static str {
                match self {
                    $(
                        define_errors!(@mixed_match_pattern $variant($($field_name),*)) => stringify!($variant),
                    )*
                }
            }
        }
    };

    // Helper: Generate mixed variant - empty becomes unit, non-empty becomes struct
    (@mixed_variant $name:ident()) => {
        $name
    };
    (@mixed_variant $name:ident($($field_name:ident: $field_type:ty),+)) => {
        $name {
            $(define_errors!(@field $field_name: $field_type)),*
        }
    };
    (@mixed_variant $name:ident($($field_name:ident: $field_type:ty),*)) => {
        define_errors!(@mixed_variant_flexible $name; $($field_name: $field_type),*)
    };

    // Helper for flexible variant generation
    (@mixed_variant_flexible $name:ident; ) => {
        $name
    };
    (@mixed_variant_flexible $name:ident; $($field_name:ident: $field_type:ty),+) => {
        $name {
            $(define_errors!(@field $field_name: $field_type)),*
        }
    };

    // Helper: Generate mixed match patterns 
    (@mixed_match_pattern $name:ident()) => {
        Self::$name
    };
    (@mixed_match_pattern $name:ident($($field_name:ident),+)) => {
        Self::$name { .. }
    };
    (@mixed_match_pattern $name:ident($($field_name:ident),*)) => {
        define_errors!(@mixed_match_flexible $name; $($field_name),*)
    };

    // Helper for flexible matching - distinguishes between empty and non-empty
    (@mixed_match_flexible $name:ident; ) => {
        Self::$name
    };
    (@mixed_match_flexible $name:ident; $($field_name:ident),+) => {
        Self::$name { .. }
    };

    // Helper: Simple logging with attributes  
    (@log_simple [$($attr:tt)*] ; $code:expr, $message:expr) => {
        define_errors!(@log_with_attrs $($attr)* ; $code, $message);
    };
    
    (@log_simple ; $code:expr, $message:expr) => {
        $crate::error!(target: module_path!(), "[{}] {}", $code, $message);
    };

    // Helper: Auto-add #[source] for fields named "source"
    (@add_source_attr source: $type:ty) => {
        #[source]
        source: $type
    };
    
    // Helper: Regular fields stay as-is
    (@add_source_attr $name:ident: $type:ty) => {
        $name: $type
    };

    // Helper: Generate the complete enum with both unit and struct variants
    (@generate_enum $name:ident; $( ($variant:ident; $msg:literal; (); $([$($attr:tt)*])?) ),*) => {
        // All unit variants
        #[derive(thiserror::Error, Debug)]
        pub enum $name {
            $(
                #[error($msg)]
                $variant,
            )*
        }

        impl $name {
            pub fn log(&self) {
                match self {
                    $(
                        Self::$variant => {
                            let code = self.code();
                            let message = self.to_string();
                            define_errors!(@log_simple $([$($attr)*])? ; code, message);
                        },
                    )*
                }
            }
            
            pub fn code(&self) -> &'static str {
                match self {
                    $(
                        Self::$variant => stringify!($variant),
                    )*
                }
            }
        }
    };
    
    (@generate_enum $name:ident; $( ($variant:ident; $msg:literal; ($($field_name:ident: $field_type:ty),+); $([$($attr:tt)*])?) ),*) => {
        // All struct variants
        #[derive(thiserror::Error, Debug)]
        pub enum $name {
            $(
                #[error($msg)]
                $variant {
                    $(define_errors!(@add_source_attr $field_name: $field_type)),+
                },
            )*
        }

        impl $name {
            pub fn log(&self) {
                match self {
                    $(
                        Self::$variant { .. } => {
                            let code = self.code();
                            let message = self.to_string();
                            define_errors!(@log_simple $([$($attr)*])? ; code, message);
                        },
                    )*
                }
            }
            
            pub fn code(&self) -> &'static str {
                match self {
                    $(
                        Self::$variant { .. } => stringify!($variant),
                    )*
                }
            }
        }
    };

    // Helper: Generate enum variant - empty becomes unit, non-empty becomes struct
    (@enum_variant $name:ident()) => {
        $name
    };
    (@enum_variant $name:ident($($field_name:ident: $field_type:ty),+)) => {
        $name {
            $(define_errors!(@field $field_name: $field_type)),*
        }
    };

    // Helper: Generate match patterns - empty becomes unit, non-empty becomes struct
    (@match_pattern $name:ident()) => {
        Self::$name
    };
    (@match_pattern $name:ident($($field_name:ident),+)) => {
        Self::$name { .. }
    };
    (@match_pattern $name:ident($($field_name:ident),*)) => {
        define_errors!(@match_pattern_flexible $name; $($field_name),*)
    };

    // Helper for flexible matching - distinguishes between empty and non-empty
    (@match_pattern_flexible $name:ident; ) => {
        Self::$name
    };
    (@match_pattern_flexible $name:ident; $($field_name:ident),+) => {
        Self::$name { .. }
    };

    // Helper: Auto-add #[source] for fields named "source"
    (@field source: $type:ty) => {
        #[source]
        source: $type
    };
    
    // Helper: Regular fields stay as-is
    (@field $name:ident: $type:ty) => {
        $name: $type
    };
    
    // Variant-specific logging helpers that handle the optional attributes pattern
    (@log_variant_with_attrs [$($attr:tt)*] ; $code:expr, $message:expr) => {
        define_errors!(@log_with_attrs $($attr)* ; $code, $message);
    };
    
    (@log_variant_with_attrs ; $code:expr, $message:expr) => {
        define_errors!(@log_with_attrs ; $code, $message);
    };
    
    // Helper: Parse LogFFI attributes and log accordingly
    (@log_with_attrs level = error, target = $target:literal ; $code:expr, $message:expr) => {
        $crate::error!(target: $target, "[{}] {}", $code, $message);
    };
    (@log_with_attrs level = warn, target = $target:literal ; $code:expr, $message:expr) => {
        $crate::warn!(target: $target, "[{}] {}", $code, $message);
    };
    (@log_with_attrs level = info, target = $target:literal ; $code:expr, $message:expr) => {
        $crate::info!(target: $target, "[{}] {}", $code, $message);
    };
    (@log_with_attrs level = debug, target = $target:literal ; $code:expr, $message:expr) => {
        $crate::debug!(target: $target, "[{}] {}", $code, $message);
    };
    (@log_with_attrs level = trace, target = $target:literal ; $code:expr, $message:expr) => {
        $crate::trace!(target: $target, "[{}] {}", $code, $message);
    };
    
    // Log level only (default target)
    (@log_with_attrs level = error ; $code:expr, $message:expr) => {
        $crate::error!(target: module_path!(), "[{}] {}", $code, $message);
    };
    (@log_with_attrs level = warn ; $code:expr, $message:expr) => {
        $crate::warn!(target: module_path!(), "[{}] {}", $code, $message);
    };
    (@log_with_attrs level = info ; $code:expr, $message:expr) => {
        $crate::info!(target: module_path!(), "[{}] {}", $code, $message);
    };
    (@log_with_attrs level = debug ; $code:expr, $message:expr) => {
        $crate::debug!(target: module_path!(), "[{}] {}", $code, $message);
    };
    (@log_with_attrs level = trace ; $code:expr, $message:expr) => {
        $crate::trace!(target: module_path!(), "[{}] {}", $code, $message);
    };
    
    // Target only (default level = error)  
    (@log_with_attrs target = $target:literal ; $code:expr, $message:expr) => {
        $crate::error!(target: $target, "[{}] {}", $code, $message);
    };
    
    // Neither level nor target (both defaults)
    (@log_with_attrs ; $code:expr, $message:expr) => {
        $crate::error!(target: module_path!(), "[{}] {}", $code, $message);
    };
    
    // Helper: Parse thiserror attributes and log accordingly  
    (@log_thiserror error $target:literal ; $code:expr, $message:expr) => {
        $crate::error!(target: $target, "[{}] {}", $code, $message);
    };
    (@log_thiserror warn $target:literal ; $code:expr, $message:expr) => {
        $crate::warn!(target: $target, "[{}] {}", $code, $message);
    };
    (@log_thiserror info $target:literal ; $code:expr, $message:expr) => {
        $crate::info!(target: $target, "[{}] {}", $code, $message);
    };
    (@log_thiserror debug $target:literal ; $code:expr, $message:expr) => {
        $crate::debug!(target: $target, "[{}] {}", $code, $message);
    };
    (@log_thiserror trace $target:literal ; $code:expr, $message:expr) => {
        $crate::trace!(target: $target, "[{}] {}", $code, $message);
    };
    
    // Thiserror level only (default target)
    (@log_thiserror error ; $code:expr, $message:expr) => {
        $crate::error!(target: module_path!(), "[{}] {}", $code, $message);
    };
    (@log_thiserror warn ; $code:expr, $message:expr) => {
        $crate::warn!(target: module_path!(), "[{}] {}", $code, $message);
    };
    (@log_thiserror info ; $code:expr, $message:expr) => {
        $crate::info!(target: module_path!(), "[{}] {}", $code, $message);
    };
    (@log_thiserror debug ; $code:expr, $message:expr) => {
        $crate::debug!(target: module_path!(), "[{}] {}", $code, $message);
    };
    (@log_thiserror trace ; $code:expr, $message:expr) => {
        $crate::trace!(target: module_path!(), "[{}] {}", $code, $message);
    };
    
    // Thiserror target only (default level = error)  
    (@log_thiserror $target:literal ; $code:expr, $message:expr) => {
        $crate::error!(target: $target, "[{}] {}", $code, $message);
    };
    
    // Thiserror neither level nor target (both defaults)
    (@log_thiserror ; $code:expr, $message:expr) => {
        $crate::error!(target: module_path!(), "[{}] {}", $code, $message);
    };

}
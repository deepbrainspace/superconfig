- JSON-RPC: ~5-10ms overhead per API call, but Rust-speed processing
- C-FFI: ~0.01ms overhead per API call, Rust-speed processing

No direct equivalent to napi-rs/PyO3 for Go. Go FFI works differently:

1. cgo (Go's built-in FFI):
   // Rust side - expose C-compatible functions
   #[no_mangle]
   pub extern "C" fn superconfig_new() -> *mut SuperConfig { ... }

// Go side - import C functions
/*
#cgo LDFLAGS: -L. -lsuperconfig
#include "superconfig.h"
*/
import "C"

func New() *SuperConfig {
return (*SuperConfig)(C.superconfig_new())
}

2. Experimental tools: rusty-go, golang-ffi (less mature)

Combining Macros - YES YOU CAN!

// Your existing Rust code with BOTH macros
#[napi] // For Node.js
#[pyclass] // For Python\
pub struct SuperConfig {
// your fields
}

#[napi]
#[pymethods]
impl SuperConfig {
#[napi(constructor)]
#[new]
pub fn new() -> Self {
// your implementation (unchanged!)
}

    #[napi]
    pub fn with_file(&mut self, path: String) -> &mut Self {
        // your implementation (unchanged!)
    }

}

Build Process:

Cargo.toml:
[features]
default = []
node = ["napi", "napi-derive"]
python = ["pyo3"]
go = [] # cgo uses different approach

[dependencies]
napi = { version = "2", optional = true }
napi-derive = { version = "2", optional = true }
pyo3 = { version = "0.20", optional = true }

Building different targets:

# Node.js binding

cargo build --features=node --lib

# Produces: target/release/libsuperconfig.dylib

# Python binding

cargo build --features=python --lib

# Produces: target/release/libsuperconfig.so

# Go needs C headers

cargo build --features=go
cbindgen --output superconfig.h # Generate C header for Go

Package Generation:

Node.js package.json (auto-generated by napi-rs):
{
"name": "superconfig",
"main": "index.js",
"files": ["superconfig.*.node"]
}

Python setup.py/pyproject.toml (generated by PyO3):
[build-system]
requires = ["maturin>=0.14,<0.15"]

Go module (manual setup needed):
// superconfig.go - wrapper around C FFI
package superconfig

/*
#cgo LDFLAGS: -L. -lsuperconfig
#include "superconfig.h"
*/
import "C"

type SuperConfig struct {
ptr *C.superconfig_t
}

func New() *SuperConfig {
return &SuperConfig{ptr: C.superconfig_new()}
}

The Challenge:

- Node.js + Python: Work beautifully together with dual macros
- Go: Needs manual C header generation and Go wrapper code
- Other languages: Each needs custom work

napi-rs (Node.js):
// Your existing Rust code + annotations
#[napi]
impl SuperConfig {
#[napi(constructor)]
pub fn new() -> Self { ... }

    #[napi]
    pub fn with_file(&mut self, path: String) -> &mut Self { ... }

}

- Reads your Rust code directly
- Generates Node.js bindings
- Performance: ~0.01ms per call (fastest possible)

PyO3 (Python):
#[pyclass]
impl SuperConfig {
#[new]
fn new() -> Self { ... }

    fn with_file(&mut self, path: String) -> &mut Self { ... }

}

- Reads your Rust code directly
- Performance: ~0.01ms per call (fastest possible)

Performance Comparison:

| Approach       | Call Overhead | Processing Speed | Languages                   |
| -------------- | ------------- | ---------------- | --------------------------- |
| napi-rs/PyO3   | ~0.01ms       | 100% Rust        | Node.js, Python only        |
| UniFfi         | ~0.01ms       | 100% Rust        | Python, Swift, Kotlin, Ruby |
| JSON-RPC       | ~5-10ms       | 100% Rust        | ALL languages               |
| CLI subprocess | ~15-50ms      | 100% Rust        | ALL languages               |

1. Go C-FFI Process:

Step 1 - Rust side (expose C functions):
// Your existing code PLUS C exports
#[no_mangle]
pub extern "C" fn superconfig_new() -> *mut SuperConfig {
let config = SuperConfig::new();
Box::into_raw(Box::new(config))
}

#[no_mangle]
pub extern "C" fn superconfig_with_file(
config: *mut SuperConfig,
path: *const c_char
) -> *mut SuperConfig {
let config = unsafe { &mut *config };
let path_str = unsafe { CStr::from_ptr(path).to_str().unwrap() };
config.with_file(path_str);
config
}

Step 2 - Generate C header:
cbindgen --output superconfig.h # Auto-generates from Rust code

Step 3 - Go wrapper:
package superconfig

/*
#cgo LDFLAGS: -lsuperconfig
#include "superconfig.h"\
*/
import "C"

type SuperConfig struct {
ptr *C.superconfig_t
}

func New() *SuperConfig {
return &SuperConfig{ptr: C.superconfig_new()}
}

func (s *SuperConfig) WithFile(path string) *SuperConfig {
cpath := C.CString(path)
C.superconfig_with_file(s.ptr, cpath)
return s
}

2. Node.js + Python - YES, Quick Win!

You're absolutely right! It would be:

// Add these macros to your existing code
#[napi]
#[pyclass]
pub struct SuperConfig {
// Your existing fields unchanged
}

#[napi]
#[pymethods]
impl SuperConfig {
#[napi(constructor)]
#[new]
pub fn new() -> Self {
// Your existing code unchanged!
}

    #[napi]
    pub fn with_file(&mut self, path: String) -> &mut Self {
        // Your existing code unchanged!
    }

}

Build commands:

# Node.js

cargo build --features=node

# Python

maturin develop --features=python

That's it! You get both languages with identical APIs.

Why Others Don't Do This:

Great observation! Most projects don't because:

1. Historical reasons - They started before these tools matured
2. Different priorities - Some prioritize simplicity over performance
3. Fear of complexity - Worry about maintaining multiple FFI layers
4. Lack of awareness - Many developers don't know this approach exists

Examples:

- Biome: Started as JavaScript-only tool, CLI was simpler
- Chatmail: Built before napi-rs matured, JSON-RPC was safer better

Unfortunately, no. Node.js (napi-rs) and Python (PyO3) are the only two with mature macro-based approaches.

Other languages require manual work:

- Go: C-FFI + manual wrapper (as discussed)
- Ruby: rb-sys (newer, less mature than napi/PyO3)
- Swift/Kotlin: UniFfi (separate .udl file required)
- C#: dotnet-bindgen (experimental)
- Java: JNI (manual setup)

So Node.js + Python really are the sweet spot for quick wins!

Publishing to PyPI + npm:

Python (PyPI):

# Build Python wheels for multiple platforms

maturin build --features=python --release --target x86_64-unknown-linux-gnu
maturin build --features=python --release --target x86_64-apple-darwin
maturin build --features=python --release --target x86_64-pc-windows-msvc

# Publish to PyPI

maturin publish --features=python

Result: pip install superconfig

Node.js (npm):

# Build Node.js bindings for multiple platforms

napi build --features=node --platform --release

# Publish to npm

npm publish

Result: npm install superconfig

Client Experience:

Python:

# Identical to your Rust API!

from superconfig import SuperConfig

config = SuperConfig()\
.with_file("base.toml")\
.with_env("APP_")\
.extract()

print(config) # Works exactly like Rust

Node.js:

// Identical to your Rust API!
import { SuperConfig } from 'superconfig';

const config = new SuperConfig()
.withFile("base.toml") // camelCase for JS convention
.withEnv("APP_")
.extract();

console.log(config); // Works exactly like Rust

TypeScript Support:

napi-rs auto-generates TypeScript definitions:
// Auto-generated superconfig.d.ts
export class SuperConfig {
constructor();
withFile(path: string): SuperConfig;
withEnv(prefix: string): SuperConfig;
extract(): ConfigResult;
}

Build Automation:

You can automate cross-platform builds with GitHub Actions:

# .github/workflows/release.yml

- name: Build Python wheels
  run: maturin build --features=python --release

- name: Build Node.js bindings
  run: napi build --features=node --release

- name: Publish to PyPI
  run: maturin publish --features=python

- name: Publish to npm
  run: npm publish

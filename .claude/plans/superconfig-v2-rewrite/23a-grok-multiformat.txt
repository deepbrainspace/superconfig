```rust
use scc::HashMap as SccHashMap;
use std::sync::Arc;
use std::sync::atomic::{AtomicU64, Ordering};
use once_cell::sync::Lazy;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

// Profile type
#[derive(Clone, PartialEq, Eq, Hash, Debug)]
pub struct Profile(String);

impl Profile {
    pub fn new(name: &str) -> Self { Self(name.to_string()) }
    pub fn default() -> Self { Self("default".to_string()) }
}

// Dynamic serde wrappers (simplified for example)
#[derive(Clone)]
pub enum DynDeserialize {
    String(String),
    Integer(i64),
    Float(f64),
    Boolean(bool),
    // Add arrays, tables, etc., as needed
}

impl DynDeserialize {
    fn to_toml(&self) -> Result<toml::Value, String> {
        match self {
            Self::String(s) => Ok(toml::Value::String(s.clone())),
            Self::Integer(i) => Ok(toml::Value::Integer(*i)),
            Self::Float(f) => Ok(toml::Value::Float(*f)),
            Self::Boolean(b) => Ok(toml::Value::Boolean(*b)),
        }
    }
}

#[derive(Clone)]
pub enum DynSerialize {
    String(String),
    Integer(i64),
    Float(f64),
    Boolean(bool),
}

impl DynSerialize {
    fn to_toml(&self) -> Result<toml::Value, String> {
        match self {
            Self::String(s) => Ok(toml::Value::String(s.clone())),
            Self::Integer(i) => Ok(toml::Value::Integer(*i)),
            Self::Float(f) => Ok(toml::Value::Float(*f)),
            Self::Boolean(b) => Ok(toml::Value::Boolean(*b)),
        }
    }
}

impl From<String> for DynSerialize {
    fn from(s: String) -> Self { Self::String(s) }
}

impl From<i64> for DynSerialize {
    fn from(i: i64) -> Self { Self::Integer(i) }
}

impl From<f64> for DynSerialize {
    fn from(f: f64) -> Self { Self::Float(f) }
}

impl From<bool> for DynSerialize {
    fn from(b: bool) -> Self { Self::Boolean(b) }
}

// ConfigFormat trait
pub trait ConfigFormat: Send + Sync {
    fn parse(&self, content: &str) -> Result<HashMap<String, DynDeserialize>, String>;
    fn serialize(&self, data: &HashMap<String, DynSerialize>) -> Result<String, String>;
}

// Format implementations
pub struct TomlFormat;
impl ConfigFormat for TomlFormat {
    fn parse(&self, content: &str) -> Result<HashMap<String, DynDeserialize>, String> {
        let value: toml::Value = toml::from_str(content).map_err(|e| e.to_string())?;
        flatten_toml(&value, "")
    }
    fn serialize(&self, data: &HashMap<String, DynSerialize>) -> Result<String, String> {
        let value = reconstruct_toml(data)?;
        toml::to_string(&value).map_err(|e| e.to_string())
    }
}

pub struct JsonFormat;
impl JsonFormat {
    fn try_parse(&self, content: &str) -> Result<HashMap<String, DynDeserialize>, String> {
        let value: serde_json::Value = serde_json::from_str(content).map_err(|e| e.to_string())?;
        flatten_json(&value, "")
    }
}
impl ConfigFormat for JsonFormat {
    fn parse(&self, content: &str) -> Result<HashMap<String, DynDeserialize>, String> {
        self.try_parse(content)
    }
    fn serialize(&self, data: &HashMap<String, DynSerialize>) -> Result<String, String> {
        let value = reconstruct_json(data)?;
        serde_json::to_string(&value).map_err(|e| e.to_string())
    }
}

pub struct YamlFormat;
impl ConfigFormat for YamlFormat {
    fn parse(&self, content: &str) -> Result<HashMap<String, DynDeserialize>, String> {
        let value: serde_yaml::Value = serde_yaml::from_str(content).map_err(|e| e.to_string())?;
        flatten_yaml(&value, "")
    }
    fn serialize(&self, data: &HashMap<String, DynSerialize>) -> Result<String, String> {
        let value = reconstruct_yaml(data)?;
        serde_yaml::to_string(&value).map_err(|e| e.to_string())
    }
}

// Flattening and reconstruction (simplified)
fn flatten_toml(value: &toml::Value, prefix: &str) -> Result<HashMap<String, DynDeserialize>, String> {
    let mut result = HashMap::new();
    if let toml::Value::Table(table) = value {
        for (key, val) in table {
            let new_prefix = if prefix.is_empty() { key.to_string() } else { format!("{}.{}", prefix, key) };
            match val {
                toml::Value::Table(_) => {
                    let sub_map = flatten_toml(val, &new_prefix)?;
                    result.extend(sub_map);
                }
                toml::Value::String(s) => { result.insert(new_prefix, DynDeserialize::String(s.clone())); }
                toml::Value::Integer(i) => { result.insert(new_prefix, DynDeserialize::Integer(*i)); }
                toml::Value::Float(f) => { result.insert(new_prefix, DynDeserialize::Float(*f)); }
                toml::Value::Boolean(b) => { result.insert(new_prefix, DynDeserialize::Boolean(*b)); }
                _ => {}
            }
        }
    }
    Ok(result)
}

fn reconstruct_toml(data: &HashMap<String, DynSerialize>) -> Result<toml::Value, String> {
    let mut result = toml::Value::Table(toml::map::Map::new());
    for (key, value) in data {
        let parts = key.split('.').collect::<Vec<_>>();
        let mut current = &mut result;
        for part in parts.iter().take(parts.len() - 1) {
            current = current.as_table_mut().unwrap().entry(*part)
                .or_insert_with(|| toml::Value::Table(toml::map::Map::new()))
                .as_table_mut().unwrap();
        }
        if let Some(last) = parts.last() {
            current.as_table_mut().unwrap().insert(last.to_string(), value.to_toml()?);
        }
    }
    Ok(result)
}

// Similar for JSON, YAML (omitted for brevity)

// Format detection
fn detect_format(content: &str, extension: Option<&str>) -> Option<&'static dyn ConfigFormat> {
    // Extension-based detection for files
    if let Some(ext) = extension {
        return match ext.to_lowercase().as_str() {
            "toml" => Some(&TomlFormat),
            "json" => Some(&JsonFormat),
            "yaml" | "yml" => Some(&YamlFormat),
            _ => None,
        };
    }

    // Heuristic + parse attempt for strings
    let content = content.trim();
    if content.starts_with('{') || content.starts_with('[') {
        if JsonFormat.try_parse(&JsonFormat, content).is_ok() {
            return Some(&JsonFormat);
        }
    }
    if content.contains(':') || content.contains('-') {
        if serde_yaml::from_str::<serde_yaml::Value>(content).is_ok() {
            return Some(&YamlFormat);
        }
    }
    if content.contains('=') || content.contains('[') {
        if toml::from_str::<toml::Value>(content).is_ok() {
            return Some(&TomlFormat);
        }
    }
    None
}

// Trait for swappable registry backends
pub trait ConfigRegistryBackend: Send + Sync {
    fn insert<T: 'static + Send + Sync>(&self, id: u64, config: T) -> Result<(), ()>;
    fn get<T: 'static + Clone>(&self, id: &u64) -> Option<T>;
}

// ConfigRegistry with multi-source support
pub struct ConfigRegistry {
    backend: Arc<SccHashMap<u64, Arc<dyn std::any::Any + Send + Sync>>>,
    keymaps: Arc<SccHashMap<Profile, Arc<SccHashMap<String, u64>>>>,
    dirty_profiles: Arc<SccHashMap<Profile, bool>>,
    selected_profile: Profile,
}

static CONFIG_REGISTRY: Lazy<ConfigRegistry> = Lazy::new(|| ConfigRegistry::new());
static NEXT_HANDLE_ID: AtomicU64 = AtomicU64::new(1);

impl ConfigRegistry {
    fn new() -> Self {
        let mut keymaps = SccHashMap::new();
        keymaps.insert(Profile::default(), Arc::new(SccHashMap::with_capacity(1000))).unwrap();
        Self {
            backend: Arc::new(SccHashMap::with_capacity(1000)),
            keymaps: Arc::new(keymaps),
            dirty_profiles: Arc::new(SccHashMap::new()),
            selected_profile: Profile::default(),
        }
    }

    fn select<T: 'static + Clone + Serialize + for<'de> Deserialize<'de>>(&self, profile: &str) -> Option<ConfigHandle<T>> {
        let profile_key = Profile::new(profile);
        if self.dirty_profiles.contains(&profile_key) {
            self.rebuild_struct(&profile_key);
        }
        self.keymaps.get(&profile_key)
            .and_then(|keymap| keymap.get(&profile.to_string()))
            .map(|id| ConfigHandle { id: *id.value(), _phantom: std::marker::PhantomData })
    }

    fn insert<T: 'static + Send + Sync>(&self, profile: &str, key: &str, config: T) -> ConfigHandle<T> {
        let id = NEXT_HANDLE_ID.fetch_add(1, Ordering::SeqCst);
        let full_key = if key.is_empty() { profile.to_string() } else { format!("{}.{}", profile, key) };
        self.backend.insert(id, Arc::new(config)).expect("Insert failed");
        let profile_keymap = self.keymaps.get(&Profile::new(profile))
            .unwrap_or_else(|| {
                let new_keymap = Arc::new(SccHashMap::with_capacity(1000));
                self.keymaps.insert(Profile::new(profile), new_keymap.clone()).unwrap();
                new_keymap
            });
        profile_keymap.insert(full_key, id).expect("Keymap insert failed");
        self.dirty_profiles.insert(Profile::new(profile), true).unwrap();
        ConfigHandle { id, _phantom: std::marker::PhantomData }
    }

    fn get<T: 'static + Clone>(&self, key: &str) -> Option<T> {
        let full_key = format!("{}.{}", self.selected_profile.0, key);
        self.keymaps.get(&self.selected_profile)
            .and_then(|keymap| keymap.get(&full_key))
            .and_then(|id| self.backend.get(id.value()))
            .map(|v| v.downcast_ref::<T>().cloned())
            .flatten()
    }

    fn get_nested<T: 'static + Clone + Serialize + for<'de> Deserialize<'de>>(&self, prefix: &str) -> Option<T> {
        let full_prefix = if prefix.is_empty() { self.selected_profile.0.clone() } else { format!("{}.{}", self.selected_profile.0, prefix) };
        let mut result = toml::Value::Table(toml::map::Map::new());
        if let Some(keymap) = self.keymaps.get(&self.selected_profile) {
            keymap.for_each(|k, v| {
                if k.starts_with(&full_prefix) && k != self.selected_profile.0 {
                    let suffix = k[full_prefix.len()..].trim_start_matches('.');
                    if !suffix.is_empty() {
                        let mut current = &mut result;
                        for part in suffix.split('.') {
                            current = current.as_table_mut().unwrap().entry(part).or_insert_with(|| toml::Value::Table(toml::map::Map::new())).as_table_mut().unwrap();
                        }
                        if let Some(value) = self.backend.get(v.value()) {
                            *current = toml::value::Value::try_from(value.downcast_ref::<String>().cloned().unwrap_or_default()).unwrap_or(toml::Value::String("".to_string()));
                        }
                    }
                }
            });
        }
        T::deserialize(&result).ok()
    }

    fn get_handle<T: 'static + Clone>(&self, key: &str) -> Option<ConfigHandle<T>> {
        let full_key = format!("{}.{}", self.selected_profile.0, key);
        self.keymaps.get(&self.selected_profile)
            .and_then(|keymap| keymap.get(&full_key))
            .map(|id| ConfigHandle { id: *id.value(), _phantom: std::marker::PhantomData })
    }

    fn merge_string(&self, content: &str) -> Result<(), String> {
        let format = detect_format(content, None).ok_or_else(|| "Failed to detect format".to_string())?;
        let flat_map = format.parse(content)?;
        for (key, value) in flat_map {
            let profile = key.split('.').next().unwrap_or("default");
            let config_key = if key.starts_with(profile) { key[profile.len()..].trim_start_matches('.') } else { &key };
            self.insert_value(profile, config_key, &value);
        }
        self.rebuild_structs();
        Ok(())
    }

    fn merge_file(&self, path: &str) -> Result<(), String> {
        let content = std::fs::read_to_string(path).map_err(|e| e.to_string())?;
        let extension = std::path::Path::new(path).extension().and_then(|e| e.to_str());
        let format = detect_format(&content, extension).ok_or_else(|| "Failed to detect format".to_string())?;
        self.merge_format(&content, format)
    }

    fn merge_format(&self, content: &str, format: &dyn ConfigFormat) -> Result<(), String> {
        let flat_map = format.parse(content)?;
        for (key, value) in flat_map {
            let profile = key.split('.').next().unwrap_or("default");
            let config_key = if key.starts_with(profile) { key[profile.len()..].trim_start_matches('.') } else { &key };
            self.insert_value(profile, config_key, &value);
        }
        self.rebuild_structs();
        Ok(())
    }

    fn to_format(&self, profile: &str, format: &dyn ConfigFormat) -> Result<String, String> {
        let profile_key = Profile::new(profile);
        let mut data = HashMap::new();
        if let Some(keymap) = self.keymaps.get(&profile_key) {
            keymap.for_each(|k, v| {
                if let Some(value) = self.backend.get(v.value()) {
                    data.insert(k.to_string(), value.downcast_ref::<String>().cloned().unwrap_or_default().into());
                }
            });
        }
        format.serialize(&data)
    }

    fn merge_env(&self, prefix: &str) -> Result<(), String> {
        for (key, value) in std::env::vars() {
            if key.starts_with(prefix) {
                let config_key = key[prefix.len()..].to_lowercase().replace('_', ".");
                let profile = config_key.split('.').next().unwrap_or("default");
                let sub_key = if config_key.starts_with(profile) { config_key[profile.len()..].trim_start_matches('.') } else { &config_key };
                self.insert_value(profile, sub_key, &DynDeserialize::String(value));
            }
        }
        self.rebuild_structs();
        Ok(())
    }

    fn merge_cli(&self, args: &[String]) -> Result<(), String> {
        let mut i = 1;
        while i < args.len() {
            if args[i].starts_with("--") {
                let key = args[i][2..].replace('_', ".");
                let value = args.get(i + 1).ok_or_else(|| format!("Missing value for {}", key))?;
                let profile = key.split('.').next().unwrap_or("default");
                let sub_key = if key.starts_with(profile) { key[profile.len()..].trim_start_matches('.') } else { &key };
                self.insert_value(profile, sub_key, &DynDeserialize::String(value.clone()));
                i += 2;
            } else {
                i += 1;
            }
        }
        self.rebuild_structs();
        Ok(())
    }

    fn insert_value(&self, profile: &str, key: &str, value: &DynDeserialize) {
        match value {
            DynDeserialize::String(s) => { self.insert(profile, key, s.clone()); }
            DynDeserialize::Integer(i) => { self.insert(profile, key, *i); }
            DynDeserialize::Float(f) => { self.insert(profile, key, *f); }
            DynDeserialize::Boolean(b) => { self.insert(profile, key, *b); }
        }
    }

    fn rebuild_structs(&self) {
        let profiles: Vec<Profile> = self.dirty_profiles.iter().map(|(p, _)| p.clone()).collect();
        for profile in profiles {
            self.rebuild_struct(&profile);
        }
    }

    fn rebuild_struct(&self, profile: &Profile) {
        let mut result = toml::Value::Table(toml::map::Map::new());
        if let Some(keymap) = self.keymaps.get(profile) {
            keymap.for_each(|k, v| {
                if k != profile.0 {
                    let parts = k.split('.').collect::<Vec<_>>();
                    let mut current = &mut result;
                    for part in parts.iter().take(parts.len() - 1) {
                        current = current.as_table_mut().unwrap().entry(*part)
                            .or_insert_with(|| toml::Value::Table(toml::map::Map::new()))
                            .as_table_mut().unwrap();
                    }
                    if let Some(value) = self.backend.get(v.value()) {
                        if let Some(last) = parts.last() {
                            current.as_table_mut().unwrap().insert(last.to_string(), toml::value::Value::try_from(value.downcast_ref::<String>().cloned().unwrap_or_default()).unwrap_or(toml::Value::String("".to_string())));
                        }
                    }
                }
            });
        }
        if let Ok(struct_value) = <Storage as Deserialize>::deserialize(&result) {
            self.insert(&profile.0, "", struct_value);
        }
        self.dirty_profiles.remove(profile).ok();
    }
}

// Handle for type-safe config access
pub struct ConfigHandle<T> {
    id: u64,
    _phantom: std::marker::PhantomData<T>,
}

impl<T: 'static + Clone> ConfigHandle<T> {
    pub fn get(&self) -> Option<T> {
        CONFIG_REGISTRY.backend.get(&self.id)
            .map(|v| v.downcast_ref::<T>().cloned())
            .flatten()
    }
}

// Example struct for deserialization
#[derive(Serialize, Deserialize, Clone)]
pub struct Storage {
    a: A,
}
#[derive(Serialize, Deserialize, Clone)]
pub struct A {
    b: B,
    k: K,
}
#[derive(Serialize, Deserialize, Clone)]
pub struct B {
    c: String,
}
#[derive(Serialize, Deserialize, Clone)]
pub struct K {
    f: String,
}

// Key/value pair API
pub struct SuperConfig;

impl SuperConfig {
    pub fn new() -> Self { Self }
    pub fn select<T: 'static + Clone + Serialize + for<'de> Deserialize<'de>>(&self, profile: &str) -> Option<ConfigHandle<T>> {
        CONFIG_REGISTRY.select(profile)
    }
    pub fn get<T: 'static + Clone>(&self, key: &str) -> Option<T> {
        CONFIG_REGISTRY.get(key)
    }
    pub fn get_nested<T: 'static + Clone + Serialize + for<'de> Deserialize<'de>>(&self, prefix: &str) -> Option<T> {
        CONFIG_REGISTRY.get_nested(prefix)
    }
    pub fn get_handle<T: 'static + Clone>(&self, key: &str) -> Option<ConfigHandle<T>> {
        CONFIG_REGISTRY.get_handle(key)
    }
    pub fn set<T: 'static + Send + Sync>(&self, profile: &str, key: &str, config: T) -> ConfigHandle<T> {
        CONFIG_REGISTRY.insert(profile, key, config)
    }
    pub fn merge_string(&self, content: &str) -> Result<(), String> {
        CONFIG_REGISTRY.merge_string(content)
    }
    pub fn merge_file(&self, path: &str) -> Result<(), String> {
        CONFIG_REGISTRY.merge_file(path)
    }
    pub fn merge_format(&self, content: &str, format: &dyn ConfigFormat) -> Result<(), String> {
        CONFIG_REGISTRY.merge_format(content, format)
    }
    pub fn to_format(&self, profile: &str, format: &dyn ConfigFormat) -> Result<String, String> {
        CONFIG_REGISTRY.to_format(profile, format)
    }
    pub fn merge_env(&self, prefix: &str) -> Result<(), String> {
        CONFIG_REGISTRY.merge_env(prefix)
    }
    pub fn merge_cli(&self, args: &[String]) -> Result<(), String> {
        CONFIG_REGISTRY.merge_cli(args)
    }
}
```

**Usage Example**:
```toml
# app.toml
[storage.a.b]
c = "d"
[storage.a.k]
f = "g"
```
```rust
let config = SuperConfig::new();
// Merge file with auto-detection
config.merge_file("app.toml").unwrap(); // ~50-100μs (TOML parse) + ~65-133μs (rebuild)
// Merge JSON string
let json = r#"{"storage": {"a": {"b": {"c": "d"}, "k": {"f": "g"}}}}"#;
config.merge_string(json).unwrap(); // ~20-50μs (JSON parse) + ~65-133μs
// Merge environment variables
std::env::set_var("APP_STORAGE_A_B_C", "d");
config.merge_env("APP_").unwrap(); // ~10-30μs + ~65-133μs
// Merge CLI arguments
let args = vec!["program".to_string(), "--storage.a.b.c".to_string(), "d".to_string()];
config.merge_cli(&args).unwrap(); // ~10-30μs + ~65-133μs
// Access
let storage: ConfigHandle<Storage> = config.select("storage").unwrap(); // ~2.3-3.5μs
assert_eq!(storage.get().unwrap().a.b.c, "d"); // ~0μs
let nested: A = config.select("storage").get_nested("a").unwrap(); // ~10-20μs
assert_eq!(nested.b.c, "d");
// Serialize to YAML
let yaml = config.to_format("storage", &YamlFormat).unwrap(); // ~10-20μs + ~50-150μs
// yaml: storage: { a: { b: { c: "d" }, k: { f: "g" } } }
```

**Python Example (via PyO3)**:
```python
config = SuperConfig()
config.merge_file("app.toml")  # ~114-189μs
config.merge_string('{"storage": {"a": {"b": {"c": "d"}, "k": {"f": "g"}}}}')  # ~85-183μs
config.merge_env("APP_")  # ~75-163μs
config.merge_cli(["program", "--storage.a.b.c", "d"])  # ~75-163μs
storage = config.select("storage")  # ~51-56μs
assert storage.a.b.c == "d"  # ~0.5-1μs
nested = config.select("storage").get_nested("a")  # ~59-71μs
assert nested.b.c == "d"
yaml = config.to_format("storage", "yaml")  # ~61-176μs
```

## Performance Analysis
- **Arbitrary Strings**:
  - **Parsing**: JSON (~20-50μs), TOML (~50-100μs), YAML (~50-150μs) for 100 keys.
  - **Flattening**: ~10-20μs.
  - **Struct Rebuild**: ~65-133μs (deferred).
  - **Auto-Detection**: ~0.1-0.5μs (heuristics) + one parse attempt (~20-150μs).
  - **Total**: ~30-170μs (not dirty), ~95-303μs (dirty).
- **Environment Variables**:
  - **Parsing**: ~10-30μs for 100 vars (iteration + string conversion).
  - **Rebuild**: ~65-133μs.
  - **Total**: ~75-163μs.
- **CLI Arguments**:
  - **Parsing**: ~10-30μs for 100 args (iteration + string parsing).
  - **Rebuild**: ~65-133μs.
  - **Total**: ~75-163μs.
- **Core Operations**: Unchanged (~4.3-6.5μs reads, ~10.3-15.5μs writes, ~2.3-3.5μs selects, ~51-56μs FFI).
- **Output**: ~10-20μs (reconstruction) + ~20-150μs (serialization), ~61-176μs FFI.
- **Memory**: ~82-93KB for 100 configs + ~20-30KB per profile, ~85-90% reduction vs. competitors (~5MB).

## Implementation Complexity
- **Effort**: ~6-8 hours total.
  - **Arbitrary Strings**: ~2-3 hours (extend `merge_format` to `merge_string`, add `detect.rs`).
  - **Environment Variables**: ~1-2 hours (add `env.rs`, key conversion logic).
  - **CLI Arguments**: ~1-2 hours (add `cli.rs`, integrate `clap` or manual parsing).
  - **Testing**: ~2 hours (add `env_loading.rs`, `cli_loading.rs`, update `format_tests.rs`).
- **Challenges**:
  - **Auto-Detection**: Heuristics may misclassify ambiguous strings (e.g., JSON-like TOML). Fallback to parse attempts ensures correctness but adds ~0.1-0.5μs.
  - **Env/CLI Naming**: Standardize key conversion (e.g., `APP_STORAGE_A_B_C` to `storage.a.b.c`) to avoid conflicts.
  - **Type Safety**: Ensure `DynDeserialize`/`DynSerialize` handle all input types (strings, integers, etc.).
- **Dependencies**: Add `serde_yaml`, `serde_json`, `clap` (optional for CLI), minimal impact (~0.5-1MB binary size).

## Are Env/CLI New Formats?
- **No**: Environment variables and CLI arguments are input sources, not file formats, as they provide flat key/value pairs without structured syntax (unlike JSON/TOML/YAML). Placing them in `sources/` (e.g., `env.rs`, `cli.rs`) separates their logic from `formats/`, which handles structured data parsing/serialization.
- **Rationale**: `formats/` is for file-based formats with nesting (JSON, TOML, YAML, INI). Env/CLI are key/value inputs like `config.set`, better suited to a dedicated module for modularity and clarity.

## Auto-Detection Feasibility
- **Files**: Extension-based detection (`.json`, `.toml`, `.yaml`, `.ini`) is reliable and fast (~0.1μs). Fallback to content-based heuristics for extensionless files adds ~20-150μs (one parse attempt).
- **Strings**: Heuristics (e.g., `{` for JSON, `:` for YAML, `=` or `[` for TOML) + parse attempts are robust but slower (~0.1-0.5μs + ~20-150μs). Order matters (JSON first for speed, as it’s fastest to parse).
- **Mitigations**:
  - Cache format detection results for repeated strings (~2-3μs after first).
  - Allow manual format specification (`merge_format`) for performance-critical cases.
  - Log detection failures for debugging.

## Conclusion
- **Multi-Source Support**: Adding arbitrary strings, environment variables, and CLI arguments is straightforward (~6-8 hours), using `merge_string`, `merge_env`, and `merge_cli`. Auto-detection is feasible with heuristics and parse attempts (~20-150μs overhead), maintaining ~4.3-6.5μs reads, ~10.3-15.5μs writes, ~51-56μs FFI, and ~82-93KB memory.
- **Module Structure**: Place env/CLI in `sources/` (not `formats/`), as they are key/value inputs, not structured formats. `formats/detect.rs` handles auto-detection, keeping `formats/` for JSON, TOML, YAML, INI.
- **Recommendation**: Implement the proposed design with `sources/` for env/CLI, `formats/detect.rs` for auto-detection, and full struct storage for performance (~0μs field access). This ensures usability (`config.a.b.c`, `merge_string`), flexibility (multiple inputs/outputs), and performance, ideal for microservices and cross-ecosystem use (Python, Node.js, WASM).


crates/superconfig/
├── Cargo.toml
├── src/
│   ├── lib.rs
│   ├── api/
│   │   ├── mod.rs
│   │   └── superconfig.rs    # merge_string, merge_env, merge_cli, merge_format, to_format
│   ├── core/
│   │   ├── mod.rs
│   │   ├── registry.rs       # ConfigRegistry with merge_string, merge_env, merge_cli
│   │   ├── profile.rs
│   │   └── handle.rs
│   ├── backend/
│   │   ├── mod.rs
│   │   ├── traits.rs
│   │   ├── scc_backend.rs
│   │   └── memory_backend.rs
│   ├── keymap/
│   │   ├── mod.rs
│   │   └── keymap.rs
│   ├── formats/
│   │   ├── mod.rs
│   │   ├── toml.rs
│   │   ├── json.rs
│   │   ├── yaml.rs
│   │   ├── ini.rs
│   │   ├── flatten.rs
│   │   ├── reconstruct.rs
│   │   └── detect.rs        # Format auto-detection
│   ├── sources/
│   │   ├── mod.rs
│   │   ├── env.rs           # Env variable parsing
│   │   └── cli.rs           # CLI argument parsing
│   ├── ffi/
│   │   ├── mod.rs
│   │   ├── python.rs
│   │   ├── nodejs.rs
│   │   └── wasm.rs
│   ├── types/
│   │   ├── mod.rs
│   │   ├── handle_id.rs
│   │   ├── errors.rs
│   │   └── config_data.rs
│   └── config_flags.rs
├── tests/
│   ├── integration/
│   │   ├── basic_operations.rs
│   │   ├── format_loading.rs
│   │   ├── format_saving.rs
│   │   ├── env_loading.rs    # Env variable tests
│   │   ├── cli_loading.rs    # CLI argument tests
│   │   ├── profile_switching.rs
│   │   └── concurrent_access.rs
│   ├── unit/
│   │   ├── backend_tests.rs
│   │   ├── keymap_tests.rs
│   │   ├── format_tests.rs
│   │   ├── source_tests.rs   # Env and CLI tests
│   │   └── registry_tests.rs
│   ├── performance/
│   │   ├── benchmark_compat.rs
│   │   ├── memory_usage.rs
│   │   └── operation_speed.rs
├── examples/
│   ├── basic_usage.rs
│   ├── multi_format.rs
│   ├── env_cli.rs            # Env and CLI usage
│   ├── ffi_demo.rs
│   └── migration_guide.rs
├── benches/
│   ├── registry_bench.rs
│   └── format_bench.rs
├── crates/
│   └── superconfig-test/
│       ├── Cargo.toml
│       ├── src/
│       │   ├── main.rs
│       │   └── scenarios/
│       │       ├── basic.rs
│       │       ├── multi_format.rs
│       │       └── concurrent.rs
│       └── configs/
│           ├── app.toml
│           ├── app.json
│           ├── app.yaml
│           ├── app.ini


Your request builds on the **SuperConfig Handle + Direct Struct** system, extending it to support arbitrary config strings (e.g., JSON, TOML, YAML) for adding to the configuration, as well as incorporating environment variables and CLI arguments as additional input sources. You also want the system to automatically detect the format of input files or strings without requiring clients to specify it explicitly. I'll outline how to structure this, addressing whether environment variables and CLI arguments should be treated as new formats under the `formats/` module, how to enable arbitrary string inputs, and how to implement format auto-detection. The response will be concise, comprehensive, and aligned with the provided instructions, leveraging prior discussion details and the current context (August 3, 2025, 4:39 PM +06). The implementation will extend the previous artifact (`config_registry_with_struct_handles.rs`) and the adjusted file structure.

---

## Requirements
- **Arbitrary Config Strings**: Allow clients to add config data via JSON, TOML, or YAML strings (e.g., `config.merge_string("{ \"a\": { \"b\": \"c\" } }")`) to the registry, updating keymap, backend, and structs.
- **Environment Variables**: Support loading configs from environment variables (e.g., `APP_STORAGE_A_B_C="d"`) with a naming convention (e.g., prefix + flattened keys).
- **CLI Arguments**: Allow configs via CLI arguments (e.g., `--storage.a.b.c=d`), parsed into the registry.
- **Format Auto-Detection**: Automatically detect whether a string or file is JSON, TOML, or YAML without client-specified format.
- **Existing Features**: Maintain full struct storage (e.g., `Storage { a: A { b: B { c: String } } }`), ~4.3-6.5μs reads, ~10.3-15.5μs writes, ~2.3-3.5μs selects, ~51-56μs FFI, ~82-93KB memory for 100 configs.
- **Usability**: Simple API (e.g., `merge_string`, `merge_env`, `merge_cli`), consistent with `merge_format` and `to_format`.

## Design
### 1. Arbitrary Config Strings
- **Approach**: Extend `merge_format` to accept arbitrary strings via a `merge_string` method, using the existing `ConfigFormat` trait to parse JSON, TOML, or YAML strings into the keymap and backend.
- **API**:
  ```rust
  impl SuperConfig {
      pub fn merge_string(&self, content: &str) -> Result<(), String> {
          CONFIG_REGISTRY.merge_string(content)
      }
  }
  ```
- **Auto-Detection**: Try parsing the string with each format (JSON, TOML, YAML) in sequence, using the first successful parse. INI is excluded from string-based auto-detection due to its ambiguous syntax (e.g., similar to plain key/value strings).
- **Implementation**: Add a `detect_format` function to attempt parsing and select the correct `ConfigFormat`.

### 2. Environment Variables
- **Approach**: Treat environment variables as a new input source, not a format under `formats/`, as they are key/value pairs without a structured file format. Use a naming convention (e.g., `APP_` prefix + flattened keys like `APP_STORAGE_A_B_C`).
- **API**:
  ```rust
  impl SuperConfig {
      pub fn merge_env(&self, prefix: &str) -> Result<(), String> {
          CONFIG_REGISTRY.merge_env(prefix)
      }
  }
  ```
- **Parsing**: Iterate environment variables, filter by prefix, convert to flattened keys (e.g., `APP_STORAGE_A_B_C -> storage.a.b.c`), and insert into the registry.

### 3. CLI Arguments
- **Approach**: Treat CLI arguments as another input source, not a format, parsed into key/value pairs (e.g., `--storage.a.b.c=d`). Use a library like `clap` for parsing.
- **API**:
  ```rust
  impl SuperConfig {
      pub fn merge_cli(&self, args: &[String]) -> Result<(), String> {
          CONFIG_REGISTRY.merge_cli(args)
      }
  }
  ```
- **Parsing**: Convert arguments to flattened keys (e.g., `--storage.a.b.c=d -> storage.a.b.c -> "d"`).

### 4. Format Auto-Detection
- **String Auto-Detection**:
  - JSON: Starts with `{` or `[`, parsable by `serde_json`.
  - TOML: Contains `[table]` or `key = value`, parsable by `toml`.
  - YAML: Contains `key: value` or `- `, parsable by `serde_yaml`.
  - Use a heuristic (e.g., first character, keyword presence) followed by parse attempts.
- **File Auto-Detection**:
  - Use file extensions (`.json`, `.toml`, `.yaml`, `.yml`, `.ini`) as primary indicator.
  - Fallback to string auto-detection for extensionless files or strings.
- **Implementation**: Add a `detect_format` function to try parsers in order (JSON, YAML, TOML) with error handling.

### 5. File Structure Integration
- **Environment Variables and CLI**: Add to a new `sources/` module, as they are input sources, not file formats:
  ```plaintext
  src/sources/
  ├── mod.rs        # Source exports
  ├── env.rs        # Environment variable parsing
  └── cli.rs        # CLI argument parsing
  ```
- **Formats**: Keep JSON, TOML, YAML, INI in `formats/`, with auto-detection logic in `formats/detect.rs`.
- **Updated Structure**:
  ```plaintext
  crates/superconfig/
  ├── Cargo.toml
  ├── src/
  │   ├── lib.rs
  │   ├── api/
  │   │   ├── mod.rs
  │   │   └── superconfig.rs    # merge_string, merge_env, merge_cli, merge_format, to_format
  │   ├── core/
  │   │   ├── mod.rs
  │   │   ├── registry.rs       # ConfigRegistry with merge_string, merge_env, merge_cli
  │   │   ├── profile.rs
  │   │   └── handle.rs
  │   ├── backend/
  │   │   ├── mod.rs
  │   │   ├── traits.rs
  │   │   ├── scc_backend.rs
  │   │   └── memory_backend.rs
  │   ├── keymap/
  │   │   ├── mod.rs
  │   │   └── keymap.rs
  │   ├── formats/
  │   │   ├── mod.rs
  │   │   ├── toml.rs
  │   │   ├── json.rs
  │   │   ├── yaml.rs
  │   │   ├── ini.rs
  │   │   ├── flatten.rs
  │   │   ├── reconstruct.rs
  │   │   └── detect.rs        # Format auto-detection
  │   ├── sources/
  │   │   ├── mod.rs
  │   │   ├── env.rs           # Env variable parsing
  │   │   └── cli.rs           # CLI argument parsing
  │   ├── ffi/
  │   │   ├── mod.rs
  │   │   ├── python.rs
  │   │   ├── nodejs.rs
  │   │   └── wasm.rs
  │   ├── types/
  │   │   ├── mod.rs
  │   │   ├── handle_id.rs
  │   │   ├── errors.rs
  │   │   └── config_data.rs
  │   └── config_flags.rs
  ├── tests/
  │   ├── integration/
  │   │   ├── basic_operations.rs
  │   │   ├── format_loading.rs
  │   │   ├── format_saving.rs
  │   │   ├── env_loading.rs    # Env variable tests
  │   │   ├── cli_loading.rs    # CLI argument tests
  │   │   ├── profile_switching.rs
  │   │   └── concurrent_access.rs
  │   ├── unit/
  │   │   ├── backend_tests.rs
  │   │   ├── keymap_tests.rs
  │   │   ├── format_tests.rs
  │   │   ├── source_tests.rs   # Env and CLI tests
  │   │   └── registry_tests.rs
  │   ├── performance/
  │   │   ├── benchmark_compat.rs
  │   │   ├── memory_usage.rs
  │   │   └── operation_speed.rs
  ├── examples/
  │   ├── basic_usage.rs
  │   ├── multi_format.rs
  │   ├── env_cli.rs            # Env and CLI usage
  │   ├── ffi_demo.rs
  │   └── migration_guide.rs
  ├── benches/
  │   ├── registry_bench.rs
  │   └── format_bench.rs
  ├── crates/
  │   └── superconfig-test/
  │       ├── Cargo.toml
  │       ├── src/
  │       │   ├── main.rs
  │       │   └── scenarios/
  │       │       ├── basic.rs
  │       │       ├── multi_format.rs
  │       │       └── concurrent.rs
  │       └── configs/
  │           ├── app.toml
  │           ├── app.json
  │           ├── app.yaml
  │           ├── app.ini
  ```

### Implementation
Below is an updated `ConfigRegistry` implementation supporting arbitrary strings, environment variables, CLI arguments, and format auto-detection, extending the previous artifact.

```rust

```rust
use scc::HashMap as SccHashMap;
use std::sync::Arc;
use std::sync::atomic::{AtomicU64, Ordering};
use once_cell::sync::Lazy;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

// Profile type
#[derive(Clone, PartialEq, Eq, Hash, Debug)]
pub struct Profile(String);

impl Profile {
    pub fn new(name: &str) -> Self { Self(name.to_string()) }
    pub fn default() -> Self { Self("default".to_string()) }
}

// Dynamic serde wrappers (simplified for example)
#[derive(Clone)]
pub enum DynDeserialize {
    String(String),
    Integer(i64),
    Float(f64),
    Boolean(bool),
    // Add arrays, tables, etc., as needed
}

impl DynDeserialize {
    fn to_toml(&self) -> Result<toml::Value, String> {
        match self {
            Self::String(s) => Ok(toml::Value::String(s.clone())),
            Self::Integer(i) => Ok(toml::Value::Integer(*i)),
            Self::Float(f) => Ok(toml::Value::Float(*f)),
            Self::Boolean(b) => Ok(toml::Value::Boolean(*b)),
        }
    }
}

#[derive(Clone)]
pub enum DynSerialize {
    String(String),
    Integer(i64),
    Float(f64),
    Boolean(bool),
}

impl DynSerialize {
    fn to_toml(&self) -> Result<toml::Value, String> {
        match self {
            Self::String(s) => Ok(toml::Value::String(s.clone())),
            Self::Integer(i) => Ok(toml::Value::Integer(*i)),
            Self::Float(f) => Ok(toml::Value::Float(*f)),
            Self::Boolean(b) => Ok(toml::Value::Boolean(*b)),
        }
    }
}

impl From<String> for DynSerialize {
    fn from(s: String) -> Self { Self::String(s) }
}

impl From<i64> for DynSerialize {
    fn from(i: i64) -> Self { Self::Integer(i) }
}

impl From<f64> for DynSerialize {
    fn from(f: f64) -> Self { Self::Float(f) }
}

impl From<bool> for DynSerialize {
    fn from(b: bool) -> Self { Self::Boolean(b) }
}

// ConfigFormat trait
pub trait ConfigFormat: Send + Sync {
    fn parse(&self, content: &str) -> Result<HashMap<String, DynDeserialize>, String>;
    fn serialize(&self, data: &HashMap<String, DynSerialize>) -> Result<String, String>;
}

// Format implementations
pub struct TomlFormat;
impl ConfigFormat for TomlFormat {
    fn parse(&self, content: &str) -> Result<HashMap<String, DynDeserialize>, String> {
        let value: toml::Value = toml::from_str(content).map_err(|e| e.to_string())?;
        flatten_toml(&value, "")
    }
    fn serialize(&self, data: &HashMap<String, DynSerialize>) -> Result<String, String> {
        let value = reconstruct_toml(data)?;
        toml::to_string(&value).map_err(|e| e.to_string())
    }
}

pub struct JsonFormat;
impl JsonFormat {
    fn try_parse(&self, content: &str) -> Result<HashMap<String, DynDeserialize>, String> {
        let value: serde_json::Value = serde_json::from_str(content).map_err(|e| e.to_string())?;
        flatten_json(&value, "")
    }
}
impl ConfigFormat for JsonFormat {
    fn parse(&self, content: &str) -> Result<HashMap<String, DynDeserialize>, String> {
        self.try_parse(content)
    }
    fn serialize(&self, data: &HashMap<String, DynSerialize>) -> Result<String, String> {
        let value = reconstruct_json(data)?;
        serde_json::to_string(&value).map_err(|e| e.to_string())
    }
}

pub struct YamlFormat;
impl ConfigFormat for YamlFormat {
    fn parse(&self, content: &str) -> Result<HashMap<String, DynDeserialize>, String> {
        let value: serde_yaml::Value = serde_yaml::from_str(content).map_err(|e| e.to_string())?;
        flatten_yaml(&value, "")
    }
    fn serialize(&self, data: &HashMap<String, DynSerialize>) -> Result<String, String> {
        let value = reconstruct_yaml(data)?;
        serde_yaml::to_string(&value).map_err(|e| e.to_string())
    }
}

// Flattening and reconstruction (simplified)
fn flatten_toml(value: &toml::Value, prefix: &str) -> Result<HashMap<String, DynDeserialize>, String> {
    let mut result = HashMap::new();
    if let toml::Value::Table(table) = value {
        for (key, val) in table {
            let new_prefix = if prefix.is_empty() { key.to_string() } else { format!("{}.{}", prefix, key) };
            match val {
                toml::Value::Table(_) => {
                    let sub_map = flatten_toml(val, &new_prefix)?;
                    result.extend(sub_map);
                }
                toml::Value::String(s) => { result.insert(new_prefix, DynDeserialize::String(s.clone())); }
                toml::Value::Integer(i) => { result.insert(new_prefix, DynDeserialize::Integer(*i)); }
                toml::Value::Float(f) => { result.insert(new_prefix, DynDeserialize::Float(*f)); }
                toml::Value::Boolean(b) => { result.insert(new_prefix, DynDeserialize::Boolean(*b)); }
                _ => {}
            }
        }
    }
    Ok(result)
}

fn reconstruct_toml(data: &HashMap<String, DynSerialize>) -> Result<toml::Value, String> {
    let mut result = toml::Value::Table(toml::map::Map::new());
    for (key, value) in data {
        let parts = key.split('.').collect::<Vec<_>>();
        let mut current = &mut result;
        for part in parts.iter().take(parts.len() - 1) {
            current = current.as_table_mut().unwrap().entry(*part)
                .or_insert_with(|| toml::Value::Table(toml::map::Map::new()))
                .as_table_mut().unwrap();
        }
        if let Some(last) = parts.last() {
            current.as_table_mut().unwrap().insert(last.to_string(), value.to_toml()?);
        }
    }
    Ok(result)
}

// Similar for JSON, YAML (omitted for brevity)

// Format detection
fn detect_format(content: &str, extension: Option<&str>) -> Option<&'static dyn ConfigFormat> {
    // Extension-based detection for files
    if let Some(ext) = extension {
        return match ext.to_lowercase().as_str() {
            "toml" => Some(&TomlFormat),
            "json" => Some(&JsonFormat),
            "yaml" | "yml" => Some(&YamlFormat),
            _ => None,
        };
    }

    // Heuristic + parse attempt for strings
    let content = content.trim();
    if content.starts_with('{') || content.starts_with('[') {
        if JsonFormat.try_parse(&JsonFormat, content).is_ok() {
            return Some(&JsonFormat);
        }
    }
    if content.contains(':') || content.contains('-') {
        if serde_yaml::from_str::<serde_yaml::Value>(content).is_ok() {
            return Some(&YamlFormat);
        }
    }
    if content.contains('=') || content.contains('[') {
        if toml::from_str::<toml::Value>(content).is_ok() {
            return Some(&TomlFormat);
        }
    }
    None
}

// Trait for swappable registry backends
pub trait ConfigRegistryBackend: Send + Sync {
    fn insert<T: 'static + Send + Sync>(&self, id: u64, config: T) -> Result<(), ()>;
    fn get<T: 'static + Clone>(&self, id: &u64) -> Option<T>;
}

// ConfigRegistry with multi-source support
pub struct ConfigRegistry {
    backend: Arc<SccHashMap<u64, Arc<dyn std::any::Any + Send + Sync>>>,
    keymaps: Arc<SccHashMap<Profile, Arc<SccHashMap<String, u64>>>>,
    dirty_profiles: Arc<SccHashMap<Profile, bool>>,
    selected_profile: Profile,
}

static CONFIG_REGISTRY: Lazy<ConfigRegistry> = Lazy::new(|| ConfigRegistry::new());
static NEXT_HANDLE_ID: AtomicU64 = AtomicU64::new(1);

impl ConfigRegistry {
    fn new() -> Self {
        let mut keymaps = SccHashMap::new();
        keymaps.insert(Profile::default(), Arc::new(SccHashMap::with_capacity(1000))).unwrap();
        Self {
            backend: Arc::new(SccHashMap::with_capacity(1000)),
            keymaps: Arc::new(keymaps),
            dirty_profiles: Arc::new(SccHashMap::new()),
            selected_profile: Profile::default(),
        }
    }

    fn select<T: 'static + Clone + Serialize + for<'de> Deserialize<'de>>(&self, profile: &str) -> Option<ConfigHandle<T>> {
        let profile_key = Profile::new(profile);
        if self.dirty_profiles.contains(&profile_key) {
            self.rebuild_struct(&profile_key);
        }
        self.keymaps.get(&profile_key)
            .and_then(|keymap| keymap.get(&profile.to_string()))
            .map(|id| ConfigHandle { id: *id.value(), _phantom: std::marker::PhantomData })
    }

    fn insert<T: 'static + Send + Sync>(&self, profile: &str, key: &str, config: T) -> ConfigHandle<T> {
        let id = NEXT_HANDLE_ID.fetch_add(1, Ordering::SeqCst);
        let full_key = if key.is_empty() { profile.to_string() } else { format!("{}.{}", profile, key) };
        self.backend.insert(id, Arc::new(config)).expect("Insert failed");
        let profile_keymap = self.keymaps.get(&Profile::new(profile))
            .unwrap_or_else(|| {
                let new_keymap = Arc::new(SccHashMap::with_capacity(1000));
                self.keymaps.insert(Profile::new(profile), new_keymap.clone()).unwrap();
                new_keymap
            });
        profile_keymap.insert(full_key, id).expect("Keymap insert failed");
        self.dirty_profiles.insert(Profile::new(profile), true).unwrap();
        ConfigHandle { id, _phantom: std::marker::PhantomData }
    }

    fn get<T: 'static + Clone>(&self, key: &str) -> Option<T> {
        let full_key = format!("{}.{}", self.selected_profile.0, key);
        self.keymaps.get(&self.selected_profile)
            .and_then(|keymap| keymap.get(&full_key))
            .and_then(|id| self.backend.get(id.value()))
            .map(|v| v.downcast_ref::<T>().cloned())
            .flatten()
    }

    fn get_nested<T: 'static + Clone + Serialize + for<'de> Deserialize<'de>>(&self, prefix: &str) -> Option<T> {
        let full_prefix = if prefix.is_empty() { self.selected_profile.0.clone() } else { format!("{}.{}", self.selected_profile.0, prefix) };
        let mut result = toml::Value::Table(toml::map::Map::new());
        if let Some(keymap) = self.keymaps.get(&self.selected_profile) {
            keymap.for_each(|k, v| {
                if k.starts_with(&full_prefix) && k != self.selected_profile.0 {
                    let suffix = k[full_prefix.len()..].trim_start_matches('.');
                    if !suffix.is_empty() {
                        let mut current = &mut result;
                        for part in suffix.split('.') {
                            current = current.as_table_mut().unwrap().entry(part).or_insert_with(|| toml::Value::Table(toml::map::Map::new())).as_table_mut().unwrap();
                        }
                        if let Some(value) = self.backend.get(v.value()) {
                            *current = toml::value::Value::try_from(value.downcast_ref::<String>().cloned().unwrap_or_default()).unwrap_or(toml::Value::String("".to_string()));
                        }
                    }
                }
            });
        }
        T::deserialize(&result).ok()
    }

    fn get_handle<T: 'static + Clone>(&self, key: &str) -> Option<ConfigHandle<T>> {
        let full_key = format!("{}.{}", self.selected_profile.0, key);
        self.keymaps.get(&self.selected_profile)
            .and_then(|keymap| keymap.get(&full_key))
            .map(|id| ConfigHandle { id: *id.value(), _phantom: std::marker::PhantomData })
    }

    fn merge_string(&self, content: &str) -> Result<(), String> {
        let format = detect_format(content, None).ok_or_else(|| "Failed to detect format".to_string())?;
        let flat_map = format.parse(content)?;
        for (key, value) in flat_map {
            let profile = key.split('.').next().unwrap_or("default");
            let config_key = if key.starts_with(profile) { key[profile.len()..].trim_start_matches('.') } else { &key };
            self.insert_value(profile, config_key, &value);
        }
        self.rebuild_structs();
        Ok(())
    }

    fn merge_file(&self, path: &str) -> Result<(), String> {
        let content = std::fs::read_to_string(path).map_err(|e| e.to_string())?;
        let extension = std::path::Path::new(path).extension().and_then(|e| e.to_str());
        let format = detect_format(&content, extension).ok_or_else(|| "Failed to detect format".to_string())?;
        self.merge_format(&content, format)
    }

    fn merge_format(&self, content: &str, format: &dyn ConfigFormat) -> Result<(), String> {
        let flat_map = format.parse(content)?;
        for (key, value) in flat_map {
            let profile = key.split('.').next().unwrap_or("default");
            let config_key = if key.starts_with(profile) { key[profile.len()..].trim_start_matches('.') } else { &key };
            self.insert_value(profile, config_key, &value);
        }
        self.rebuild_structs();
        Ok(())
    }

    fn to_format(&self, profile: &str, format: &dyn ConfigFormat) -> Result<String, String> {
        let profile_key = Profile::new(profile);
        let mut data = HashMap::new();
        if let Some(keymap) = self.keymaps.get(&profile_key) {
            keymap.for_each(|k, v| {
                if let Some(value) = self.backend.get(v.value()) {
                    data.insert(k.to_string(), value.downcast_ref::<String>().cloned().unwrap_or_default().into());
                }
            });
        }
        format.serialize(&data)
    }

    fn merge_env(&self, prefix: &str) -> Result<(), String> {
        for (key, value) in std::env::vars() {
            if key.starts_with(prefix) {
                let config_key = key[prefix.len()..].to_lowercase().replace('_', ".");
                let profile = config_key.split('.').next().unwrap_or("default");
                let sub_key = if config_key.starts_with(profile) { config_key[profile.len()..].trim_start_matches('.') } else { &config_key };
                self.insert_value(profile, sub_key, &DynDeserialize::String(value));
            }
        }
        self.rebuild_structs();
        Ok(())
    }

    fn merge_cli(&self, args: &[String]) -> Result<(), String> {
        let mut i = 1;
        while i < args.len() {
            if args[i].starts_with("--") {
                let key = args[i][2..].replace('_', ".");
                let value = args.get(i + 1).ok_or_else(|| format!("Missing value for {}", key))?;
                let profile = key.split('.').next().unwrap_or("default");
                let sub_key = if key.starts_with(profile) { key[profile.len()..].trim_start_matches('.') } else { &key };
                self.insert_value(profile, sub_key, &DynDeserialize::String(value.clone()));
                i += 2;
            } else {
                i += 1;
            }
        }
        self.rebuild_structs();
        Ok(())
    }

    fn insert_value(&self, profile: &str, key: &str, value: &DynDeserialize) {
        match value {
            DynDeserialize::String(s) => { self.insert(profile, key, s.clone()); }
            DynDeserialize::Integer(i) => { self.insert(profile, key, *i); }
            DynDeserialize::Float(f) => { self.insert(profile, key, *f); }
            DynDeserialize::Boolean(b) => { self.insert(profile, key, *b); }
        }
    }

    fn rebuild_structs(&self) {
        let profiles: Vec<Profile> = self.dirty_profiles.iter().map(|(p, _)| p.clone()).collect();
        for profile in profiles {
            self.rebuild_struct(&profile);
        }
    }

    fn rebuild_struct(&self, profile: &Profile) {
        let mut result = toml::Value::Table(toml::map::Map::new());
        if let Some(keymap) = self.keymaps.get(profile) {
            keymap.for_each(|k, v| {
                if k != profile.0 {
                    let parts = k.split('.').collect::<Vec<_>>();
                    let mut current = &mut result;
                    for part in parts.iter().take(parts.len() - 1) {
                        current = current.as_table_mut().unwrap().entry(*part)
                            .or_insert_with(|| toml::Value::Table(toml::map::Map::new()))
                            .as_table_mut().unwrap();
                    }
                    if let Some(value) = self.backend.get(v.value()) {
                        if let Some(last) = parts.last() {
                            current.as_table_mut().unwrap().insert(last.to_string(), toml::value::Value::try_from(value.downcast_ref::<String>().cloned().unwrap_or_default()).unwrap_or(toml::Value::String("".to_string())));
                        }
                    }
                }
            });
        }
        if let Ok(struct_value) = <Storage as Deserialize>::deserialize(&result) {
            self.insert(&profile.0, "", struct_value);
        }
        self.dirty_profiles.remove(profile).ok();
    }
}

// Handle for type-safe config access
pub struct ConfigHandle<T> {
    id: u64,
    _phantom: std::marker::PhantomData<T>,
}

impl<T: 'static + Clone> ConfigHandle<T> {
    pub fn get(&self) -> Option<T> {
        CONFIG_REGISTRY.backend.get(&self.id)
            .map(|v| v.downcast_ref::<T>().cloned())
            .flatten()
    }
}

// Example struct for deserialization
#[derive(Serialize, Deserialize, Clone)]
pub struct Storage {
    a: A,
}
#[derive(Serialize, Deserialize, Clone)]
pub struct A {
    b: B,
    k: K,
}
#[derive(Serialize, Deserialize, Clone)]
pub struct B {
    c: String,
}
#[derive(Serialize, Deserialize, Clone)]
pub struct K {
    f: String,
}

// Key/value pair API
pub struct SuperConfig;

impl SuperConfig {
    pub fn new() -> Self { Self }
    pub fn select<T: 'static + Clone + Serialize + for<'de> Deserialize<'de>>(&self, profile: &str) -> Option<ConfigHandle<T>> {
        CONFIG_REGISTRY.select(profile)
    }
    pub fn get<T: 'static + Clone>(&self, key: &str) -> Option<T> {
        CONFIG_REGISTRY.get(key)
    }
    pub fn get_nested<T: 'static + Clone + Serialize + for<'de> Deserialize<'de>>(&self, prefix: &str) -> Option<T> {
        CONFIG_REGISTRY.get_nested(prefix)
    }
    pub fn get_handle<T: 'static + Clone>(&self, key: &str) -> Option<ConfigHandle<T>> {
        CONFIG_REGISTRY.get_handle(key)
    }
    pub fn set<T: 'static + Send + Sync>(&self, profile: &str, key: &str, config: T) -> ConfigHandle<T> {
        CONFIG_REGISTRY.insert(profile, key, config)
    }
    pub fn merge_string(&self, content: &str) -> Result<(), String> {
        CONFIG_REGISTRY.merge_string(content)
    }
    pub fn merge_file(&self, path: &str) -> Result<(), String> {
        CONFIG_REGISTRY.merge_file(path)
    }
    pub fn merge_format(&self, content: &str, format: &dyn ConfigFormat) -> Result<(), String> {
        CONFIG_REGISTRY.merge_format(content, format)
    }
    pub fn to_format(&self, profile: &str, format: &dyn ConfigFormat) -> Result<String, String> {
        CONFIG_REGISTRY.to_format(profile, format)
    }
    pub fn merge_env(&self, prefix: &str) -> Result<(), String> {
        CONFIG_REGISTRY.merge_env(prefix)
    }
    pub fn merge_cli(&self, args: &[String]) -> Result<(), String> {
        CONFIG_REGISTRY.merge_cli(args)
    }
}
```

**Usage Example**:
```toml
# app.toml
[storage.a.b]
c = "d"
[storage.a.k]
f = "g"
```
```rust
let config = SuperConfig::new();
// Merge file with auto-detection
config.merge_file("app.toml").unwrap(); // ~50-100μs (TOML parse) + ~65-133μs (rebuild)
// Merge JSON string
let json = r#"{"storage": {"a": {"b": {"c": "d"}, "k": {"f": "g"}}}}"#;
config.merge_string(json).unwrap(); // ~20-50μs (JSON parse) + ~65-133μs
// Merge environment variables
std::env::set_var("APP_STORAGE_A_B_C", "d");
config.merge_env("APP_").unwrap(); // ~10-30μs + ~65-133μs
// Merge CLI arguments
let args = vec!["program".to_string(), "--storage.a.b.c".to_string(), "d".to_string()];
config.merge_cli(&args).unwrap(); // ~10-30μs + ~65-133μs
// Access
let storage: ConfigHandle<Storage> = config.select("storage").unwrap(); // ~2.3-3.5μs
assert_eq!(storage.get().unwrap().a.b.c, "d"); // ~0μs
let nested: A = config.select("storage").get_nested("a").unwrap(); // ~10-20μs
assert_eq!(nested.b.c, "d");
// Serialize to YAML
let yaml = config.to_format("storage", &YamlFormat).unwrap(); // ~10-20μs + ~50-150μs
// yaml: storage: { a: { b: { c: "d" }, k: { f: "g" } } }
```

**Python Example (via PyO3)**:
```python
config = SuperConfig()
config.merge_file("app.toml")  # ~114-189μs
config.merge_string('{"storage": {"a": {"b": {"c": "d"}, "k": {"f": "g"}}}}')  # ~85-183μs
config.merge_env("APP_")  # ~75-163μs
config.merge_cli(["program", "--storage.a.b.c", "d"])  # ~75-163μs
storage = config.select("storage")  # ~51-56μs
assert storage.a.b.c == "d"  # ~0.5-1μs
nested = config.select("storage").get_nested("a")  # ~59-71μs
assert nested.b.c == "d"
yaml = config.to_format("storage", "yaml")  # ~61-176μs
```

## Performance Analysis
- **Arbitrary Strings**:
  - **Parsing**: JSON (~20-50μs), TOML (~50-100μs), YAML (~50-150μs) for 100 keys.
  - **Flattening**: ~10-20μs.
  - **Struct Rebuild**: ~65-133μs (deferred).
  - **Auto-Detection**: ~0.1-0.5μs (heuristics) + one parse attempt (~20-150μs).
  - **Total**: ~30-170μs (not dirty), ~95-303μs (dirty).
- **Environment Variables**:
  - **Parsing**: ~10-30μs for 100 vars (iteration + string conversion).
  - **Rebuild**: ~65-133μs.
  - **Total**: ~75-163μs.
- **CLI Arguments**:
  - **Parsing**: ~10-30μs for 100 args (iteration + string parsing).
  - **Rebuild**: ~65-133μs.
  - **Total**: ~75-163μs.
- **Core Operations**: Unchanged (~4.3-6.5μs reads, ~10.3-15.5μs writes, ~2.3-3.5μs selects, ~51-56μs FFI).
- **Output**: ~10-20μs (reconstruction) + ~20-150μs (serialization), ~61-176μs FFI.
- **Memory**: ~82-93KB for 100 configs + ~20-30KB per profile, ~85-90% reduction vs. competitors (~5MB).

## Implementation Complexity
- **Effort**: ~6-8 hours total.
  - **Arbitrary Strings**: ~2-3 hours (extend `merge_format` to `merge_string`, add `detect.rs`).
  - **Environment Variables**: ~1-2 hours (add `env.rs`, key conversion logic).
  - **CLI Arguments**: ~1-2 hours (add `cli.rs`, integrate `clap` or manual parsing).
  - **Testing**: ~2 hours (add `env_loading.rs`, `cli_loading.rs`, update `format_tests.rs`).
- **Challenges**:
  - **Auto-Detection**: Heuristics may misclassify ambiguous strings (e.g., JSON-like TOML). Fallback to parse attempts ensures correctness but adds ~0.1-0.5μs.
  - **Env/CLI Naming**: Standardize key conversion (e.g., `APP_STORAGE_A_B_C` to `storage.a.b.c`) to avoid conflicts.
  - **Type Safety**: Ensure `DynDeserialize`/`DynSerialize` handle all input types (strings, integers, etc.).
- **Dependencies**: Add `serde_yaml`, `serde_json`, `clap` (optional for CLI), minimal impact (~0.5-1MB binary size).

## Are Env/CLI New Formats?
- **No**: Environment variables and CLI arguments are input sources, not file formats, as they provide flat key/value pairs without structured syntax (unlike JSON/TOML/YAML). Placing them in `sources/` (e.g., `env.rs`, `cli.rs`) separates their logic from `formats/`, which handles structured data parsing/serialization.
- **Rationale**: `formats/` is for file-based formats with nesting (JSON, TOML, YAML, INI). Env/CLI are key/value inputs like `config.set`, better suited to a dedicated module for modularity and clarity.

## Auto-Detection Feasibility
- **Files**: Extension-based detection (`.json`, `.toml`, `.yaml`, `.ini`) is reliable and fast (~0.1μs). Fallback to content-based heuristics for extensionless files adds ~20-150μs (one parse attempt).
- **Strings**: Heuristics (e.g., `{` for JSON, `:` for YAML, `=` or `[` for TOML) + parse attempts are robust but slower (~0.1-0.5μs + ~20-150μs). Order matters (JSON first for speed, as it’s fastest to parse).
- **Mitigations**:
  - Cache format detection results for repeated strings (~2-3μs after first).
  - Allow manual format specification (`merge_format`) for performance-critical cases.
  - Log detection failures for debugging.

## Conclusion
- **Multi-Source Support**: Adding arbitrary strings, environment variables, and CLI arguments is straightforward (~6-8 hours), using `merge_string`, `merge_env`, and `merge_cli`. Auto-detection is feasible with heuristics and parse attempts (~20-150μs overhead), maintaining ~4.3-6.5μs reads, ~10.3-15.5μs writes, ~51-56μs FFI, and ~82-93KB memory.
- **Module Structure**: Place env/CLI in `sources/` (not `formats/`), as they are key/value inputs, not structured formats. `formats/detect.rs` handles auto-detection, keeping `formats/` for JSON, TOML, YAML, INI.
- **Recommendation**: Implement the proposed design with `sources/` for env/CLI, `formats/detect.rs` for auto-detection, and full struct storage for performance (~0μs field access). This ensures usability (`config.a.b.c`, `merge_string`), flexibility (multiple inputs/outputs), and performance, ideal for microservices and cross-ecosystem use (Python, Node.js, WASM).

If you’d like a specific module implementation (e.g., `env.rs`, `detect.rs`), additional format support (e.g., INI), or benchmarks, let me know!